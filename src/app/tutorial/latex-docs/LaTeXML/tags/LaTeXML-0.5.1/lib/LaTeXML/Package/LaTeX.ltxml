# -*- CPERL -*-
# /=====================================================================\ #
# |  LaTeX                                                              | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

#**********************************************************************
# Organized following 
#  "LaTeX: A Document Preparation System"
#   by Leslie Lamport
#   2nd edition
# Addison Wesley, 1994
# Appendix C. Reference Manual
#**********************************************************************
# NOTE: A lot of this should be in Primitives.pm 
# either builtin, or inherited from plain.
#**********************************************************************
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use XML::LibXML;
use LaTeXML::Util::Pathname;
no warnings 'redefine';

#**********************************************************************
# C.1.  Commands and Environments.
#**********************************************************************

#======================================================================
# C.1.1 Command Names and Arguments
#======================================================================
# Nothing...

#======================================================================
# C.1.2 Environments
#======================================================================

# In LaTeX, \newenvironment{env} defines \env and \endenv.
# \begin{env} & \end{env} open/close a group, and invoke these.
# In fact, the \env & \endenv don't have to have been created by
# \newenvironment; And in fact \endenv doesn't even have to be defined!
# [it is created by \csname, and equiv to \relax if no previous defn]

# We need to respect these usages here, but we also want to be able
# to define environment constructors that `capture' the body so that
# it can be processed specially, if needed.  These are the magic
# '\begin{env}', '\end{env}' control sequences created by DefEnvironment.

DefExpandable('\begin{}',sub { 
  my($gullet,$env)=@_;
  my $name = $env->toString;
  if(LookupDefinition(T_CS("\\begin{$name}"))){
    T_CS("\\begin{$name}"); } # Magic cs!
  else {			# If not defined, let stomach handle it.
    (T_CS('\begingroup'),T_CS("\\$name")); }});

DefExpandable('\end{}',  sub { 
  my($gullet,$env)=@_;
  my $name = $env->toString;
  my $t;
  if   (LookupDefinition($t=T_CS("\\end{$name}"))){ $t; } # Magic CS!
  elsif(LookupDefinition($t=T_CS("\\end$name")))  { ($t, T_CS('\endgroup')); }
  else { ( T_CS('\endgroup')); }});

#======================================================================
# C.1.3 Fragile Commands
#======================================================================
# Because of the way we `move information', revertable and pre-processed,
# I don't think we actually need to do anything ... 
# [Course that means we're not _really_ TeX!]
DefExpandable('\protect',undef);

#======================================================================
# C.1.4 Declarations
#======================================================================
# actual implementation later.
#======================================================================
# C.1.5 Invisible Commands
#======================================================================
# actual implementation later.

#======================================================================
# C.1.6 The \\ Command
#======================================================================
# In math, \\ is just a formatting hint, unless within an array, cases, .. environment.
DefConstructor("\\\\ OptionalMatch:* []",
	       "?#isMath(<ltx:XMHint name='\\'/>)(\n)", alias=>"\\\\\n");

#**********************************************************************
# C.2. The Structure of the Document
#**********************************************************************
#   prepended files (using filecontents environment)
#   preamble (starting with \documentclass)
#   \begin{document}
#    text
#   \end{document}

DefEnvironment('{document}',
	       '<ltx:document>#body</ltx:document>',
	       beforeDigest=> sub { AssignValue(inPreamble=>0); },
	       afterDigest=> sub { $_[0]->getGullet->flush; return; });

#**********************************************************************
# C.3. Sentences and Paragraphs
#**********************************************************************

#======================================================================
# C.3.1 Making Sentences
#======================================================================
# quotes;  should these be handled in DOM/construction?
# dashes:  We'll need some sort of Ligature analog, or something like
# Omega's OTP, to combine sequences of "-" into endash, emdash,
# Perhaps it also applies more semantically?
# Such as interpreting certain sequences as section headings,
# or math constructs.

# Spacing; in Primitives.pm

# Special Characters; in Primitives.pm

# Logos
# \TeX is in Primitives.pm
DefConstructor('\LaTeX', 'LaTeX');

our @MonthNames=(qw( January February March April May June
		     July August September October November December));
DefExpandable('\today',sub { 
   Explode($MonthNames[LookupValue('\month')->valueOf-1]
	   ." ".LookupValue('\day')->valueOf
	   .', '.LookupValue('\year')->valueOf); });

DefConstructor('\emph{}', "<ltx:emph>#1</ltx:emph>", mode=>'text');

#======================================================================
# C.3.2 Making Paragraphs
#======================================================================
# \noindent, \indent, \par in Primitives.pm

# Style parameters
# \parindent, \baselineskip, \parskip alreadin in Primitives.pm

#======================================================================
# C.3.3 Footnotes
#======================================================================
# NOTE: probably should default the mark to some counter?
DefConstructor('\footnote[]{}',
	       "<ltx:note class='foot' ?#1(mark='#1')>#2</ltx:note>");
# NOTE: DOM should reattach the footnotetext to the footnotemark ?
#  Hmm, in general the mark & text _could_ come in either order...
DefConstructor('\footnotemark[]',""); # ????
DefConstructor('\footnotetext[]{}',
	       "<ltx:note class='foot' ?#1(mark='#1')>#2</ltx:note>");

# Style parameters
DefRegister('\footnotesep' => Dimension(0));
DefPrimitive('\footnoterule',undef);

#======================================================================
# C.3.4 Accents and Special Symbols
#======================================================================
# See Primitives.pm

# See Section 3.3.2 Mathematical Symbols, below

#**********************************************************************
# C.4 Sectioning and Table of Contents
#**********************************************************************

#======================================================================
# C.4.1 Sectioning Commands.
#======================================================================
# Note that LaTeX allows fairly arbitrary stuff in \the<ctr>, although
# it can get you in trouble.  However, in almost all cases, the result
# is plain text.  So, I'm putting refnum as an attribute, where I like it!
# You want something else? Redefine!

# Also, we're adding an id to each, that is parallel to the refnum, but
# valid as an ID.  You can tune the representation by defining, eg. \thesection@ID

# A little more messy than seems necessary:
#  We don't know whether to step the counter and update \@currentlabel until we see the '*',
# but we have to know it before we digest the title, since \label can be there!
foreach my $sec (qw(part chapter section subsection subsubsection paragraph subparagraph)){
  Tag("ltx:$sec", autoClose=>1);
  DefExpandable('\\'.$sec.' OptionalMatch:*',
		sub { 
		  my($gullet,$flag)=@_;
		  if($flag){
		    refStepID($sec);
		    (T_CS('\\@@'.$sec),T_OTHER('['),T_OTHER(']'),T_OTHER('['),T_CS('\@currentID'),T_OTHER(']')); }
		  else {
		    refStepCounter($sec);
		    (T_CS('\\@@'.$sec),T_OTHER('['),T_CS('\@currentlabel'),T_OTHER(']'),
		     T_OTHER('['),T_CS('\@currentID'),T_OTHER(']')); }});
  DefConstructor('\\@@'.$sec.'[][][]{}',
		 "<ltx:$sec ?#1(refnum='#1') id='#2'>"
		 . "<ltx:title>#4</ltx:title>"
		 . "?#3(<ltx:toctitle>#3</ltx:toctitle>)",
		 bounded=>1); }

# Not sure if this is best, but if no explicit \section'ing...
Tag('ltx:section',autoOpen=>1);
#======================================================================
# C.4.2 The Appendix
#======================================================================
# NOTE: 2 options:
#  1) redefine \section, etc to produce <appendix>, <subappendix>, etc.
#  2) Wrap remainder of doc with <appendix>
# DefPrimitive('\appendix');

#======================================================================
# C.4.3 Table of Contents
#======================================================================
# Ignore these; leave it up to post processing.
DefPrimitive('\tableofcontents', undef);
DefPrimitive('\listoffigures',   undef);
DefPrimitive('\listoftables',    undef);

DefPrimitive('\addcontentsline{}{}{}', undef);
DefPrimitive('\numberline{}{}', undef);
DefPrimitive('\addtocontents{}{}', undef);

#======================================================================
# C.4.4 Style registers
#======================================================================
DefRegister('\secnumdepth' => Number(0));
DefRegister('\tocdepth'    => Number(0));

#**********************************************************************
# C.5 Classes, Packages and Page Styles
#**********************************************************************

#======================================================================
# C.5.1 Document Class
#======================================================================
# \documentclass is defined in Primitives.pm, to automatically switch
# to LaTeX mode when processing LaTeX files.

# Style Parameters
DefRegister('\bibindent'    => Dimension(0));
DefRegister('\columnsep'    => Dimension(0));
DefRegister('\columnseprule'=> Dimension(0));
DefRegister('\mathindent'   => Dimension(0));

#======================================================================
# C.5.2 Packages
#======================================================================
# We'll prefer to load package.pm, but will try package.sty or 
# package.tex (the latter being unlikely to work, but....)
# See Stomach.pm for details
# Ignorable packages ??
# pre-defined packages??

DefConstructor('\usepackage[]{}',
	       "<?latexml package='#2' ?#1(options='#1')?>",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $options=$whatsit->getArg(1);
				  my $packages=$whatsit->getArg(2);

				  my @pkgs = split(',',$packages->toString);
				  $options = [($options ? split(',',($options->toString)) :())];
				  map(RequirePackage($_,options=>$options),@pkgs);
				  return});
DefConstructor('\RequirePackage[]{}',
	       "<?latexml package='#2' ?#1(options='#1')?>",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $options=$whatsit->getArg(1);
				  my $package=$whatsit->getArg(2);
				  $options = [($options ? split(',',($options->toString)) :())];
				  RequirePackage(ToString($package), options=>$options); });
DefConstructor('\LoadClass[]{}',
	       "<?latexml class='#2' ?#1(options='#1')?>",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $options=$whatsit->getArg(1);
				  my $class=$whatsit->getArg(2);
				  $options = [($options ? split(',',($options->toString)) :())];
				  RequirePackage(ToString($class), options=>$options); });

#======================================================================
# C.5.3 Page Styles
#======================================================================
# Ignored
DefPrimitive('\pagestyle{}',    undef);
DefPrimitive('\thispagestyle{}',undef);
DefPrimitive('\markright{}',    undef);
DefPrimitive('\markboth{}{}',   undef);
DefPrimitive('\pagenumbering{}',undef);
DefPrimitive('\twocolumn[]',    undef);
DefPrimitive('\onecolumn',      undef);

# Style parameters from Fig. C.3, p.182
DefRegister('\paperheight'   => Dimension(0));
DefRegister('\paperwidth'    => Dimension(0));
DefRegister('\textheight'    => Dimension(0));
DefRegister('\textwidth'     => Dimension('6in'));
DefRegister('\topmargin'     => Dimension(0));
DefRegister('\headheight'    => Dimension(0));
DefRegister('\headsep'       => Dimension(0));
DefRegister('\footskip'      => Dimension(0));
DefRegister('\evensidemargin'=> Dimension(0));
DefRegister('\oddsidemargin' => Dimension(0));
DefRegister('\marginparwidth'=> Dimension(0));
DefRegister('\marginparsep'  => Dimension(0));
DefRegister('\columnwidth'   => Dimension('6in'));
DefRegister('\linewidth  '   => Dimension('6in'));
DefRegister('\baselinestretch'   => Dimension(0));

#======================================================================
# C.5.4 The Title Page and Abstract
#======================================================================

DefMacro('\@title','');
DefMacro('\@author','');
DefMacro('\@date','\today');
DefPrimitive('\title{}',    sub { DefMacro('\@title',$_[1])});
DefPrimitive('\author{}',   sub { DefMacro('\@author',$_[1])});
DefPrimitive('\date{}',     sub { DefMacro('\@date',$_[1])});
DefConstructor('\thanks{}', "<ltx:thanks>#1</ltx:thanks>");

# Introduce secret control sequences to format the title, date, etc.
# These will be used by \maketitle when the time comes.
DefConstructor('\fmt@title{}', "<ltx:title>#1</ltx:title>");
DefConstructor('\fmt@author{}', "<ltx:author>#1</ltx:author>");
# Would be nice to put the ISO date as an attribute!
DefConstructor('\fmt@date{}', "<ltx:creationdate>#1</ltx:creationdate>");
# This needs to be a macro so that \@author, etal, get expanded.
DefMacro('\maketitle', '\fmt@title{\@title}\fmt@author{\@author}\fmt@date{\@date}');

DefEnvironment('{abstract}','<ltx:abstract>#body</ltx:abstract>');
# Presumably you'll do whatever you need to specify author, etc ???
DefEnvironment('{titlepage}','#body');

#**********************************************************************
# C.6 Displayed Paragraphs
#**********************************************************************
DefEnvironment('{center}',
	       '<ltx:centering>#body</ltx:centering>');
DefEnvironment('{centering}',
	       '<ltx:centering>#body</ltx:centering>');
# NOTE: center the _line_ (till \\ or \par or ?) ! How to get it?
DefPrimitive('\centering',undef);

#======================================================================-
# C.6.1 Quotations and Verse
#======================================================================-
DefEnvironment('{quote}',   
	       '<ltx:quote>#body</ltx:quote>');
DefEnvironment('{quotation}',
	       '<ltx:quotation>#body</ltx:quotation>');
# NOTE: Handling of \\ within these environments?
DefEnvironment('{verse}',
	       '<ltx:verse>#body</ltx:verse>');

#======================================================================
# C.6.2 List-Making environments
#======================================================================
Tag('ltx:item', autoClose=>1);
DefConstructor('\item[]',
	       "<ltx:item>?#1(<ltx:tag>#1</ltx:tag>)");

sub refStepItemCounter {
  refStepCounter('enum'.ToString(Tokens(roman(LookupValue('itemlevel'))))); }

sub beforeItemize {
  my($type)=@_;
  my $level = AssignValue(itemlevel=>LookupValue('itemlevel')+1);
  Let('\item'=>"\\".$type.'@item');
  resetCounter('enum'.ToString(Tokens(roman(LookupValue('itemlevel')))));
}

DefConstructor('\itemize@item[]',
	       "<ltx:item id='#id'>?#1(<ltx:tag>#1</ltx:tag>)",
	       properties=>sub{ refStepItemCounter(); });
DefConstructor('\enumerate@item[]',
	       "<ltx:item id='#id' refnum='#refnum'>?#1(<ltx:tag>#1</ltx:tag>)",
	       properties=>sub{ refStepItemCounter(); });
DefConstructor('\description@item[]',
	       "<ltx:item id='#id'>?#1(<ltx:tag>#1</ltx:tag>)",
	       properties=>sub{ refStepItemCounter(); });

AssignValue(itemlevel=>0);

  
DefEnvironment('{itemize}',
	       "<ltx:itemize id='#id'>#body</ltx:itemize>",
	       beforeDigest=>sub { beforeItemize('itemize'); },
	       properties=>sub { refStepCounter('@itemize'); });
DefEnvironment('{enumerate}',
	       "<ltx:enumerate  id='#id'>#body</ltx:enumerate>",
	      beforeDigest=>sub { beforeItemize('enumerate'); },
	       properties=>sub { refStepCounter('@itemize'); });
DefEnvironment('{description}',
	       "<ltx:description  id='#id'>#body</ltx:description>",
	       beforeDigest=>sub { beforeItemize('description'); },
	       properties=>sub { refStepCounter('@itemize'); });

# NOTE: Do I need to do anything with
# \labelitemi, labelitemii, labelitemiii or labelitemiv ?
# Probably would be useful (once I've got counters properly implemented)
# to add a number to the items.

#======================================================================
# C.6.3 The list and trivlist environments.
#======================================================================
# Mostly just punting, here; you probably want a more meaningful name
# for your list if you want better XML.
DefEnvironment('{list}{}{}',
	       "<ltx:list default_label='#1' declarations='#2'>#body</ltx:list>");
DefEnvironment('{trivlist}',
	       '<ltx:trivlist>#body</ltx:trivlist>');

DefRegister('\topsep'        => Glue(0));
DefRegister('\partopsep'     => Glue(0));
DefRegister('\itemsep'       => Glue(0));
DefRegister('\parsep'        => Glue(0));
DefRegister('\leftmargin'    => Dimension(0));
DefRegister('\rightmargin'   => Dimension(0));
DefRegister('\listparindent' => Dimension(0));
DefRegister('\itemindent'    => Dimension(0));
DefRegister('\labelsep'      => Dimension(0));

# NOTE: Eventually use \makelabel to construct the list ?
#\makelabel{label}
# \usecounter{ctr}

#======================================================================
# C.6.4 Verbatim
#======================================================================

# NOTE: how's the best way to get verbatim material through?
DefEnvironment('{verbatim}', '<ltx:verbatim>#body</ltx:verbatim>');
DefEnvironment('{verbatim*}','<ltx:verbatim>#body</ltx:verbatim>');

# verbatim is a bit of special case;
# It looks like an environment, but it only ends with an explicit "\end{verbatim}" on it's own line.
# So, we'll end up doing things more manually.
# We're going to sidestep the Gullet for inputting, 
# and also the usual environment capture.
InstallDefinition(LaTeXML::Constructor
		  ->new(T_CS('\begin{verbatim}'),undef,
			"<ltx:verbatim font='#font'>#body</ltx:verbatim>",
			beforeDigest=>[sub { $_[0]->bgroup; 
					     AssignValue(current_environment=>'verbatim');
					     MergeFont(family=>'typewriter');
					     Digest(T_CS('\par')); }],
			afterDigest=>[sub {
					my($stomach,$whatsit)=@_;
					$stomach->egroup;
					my $font = $whatsit->getFont;
					my $loc  = $whatsit->getLocator;
					my @lines = $stomach->getGullet->getMouth->readRawLines("\\end{verbatim}");
					# Note last line ends up as Whatsit's "trailer"
					$whatsit->setBody(map(LaTeXML::Box->new($_,$font,$loc,T_OTHER($_)),
							      @lines, "\end{verbatim}"));
					return; }]));

# WARNING: This code binds $STATE to a simple State object with known fixed catcodes.
# The State normally contains ALL the bindings, etc and links to other important objects.
# We CAN do that here, since we are ONLY tokenizing from a new Mouth, bypassing stomach & gullet.
# However, be careful with any changes.

# Hmm, this should really be constructor or something so that at least typewriter font
# is used, if not wrapped in a <verb> something???
our $EMPTY_CATTABLE=LaTeXML::State->new(catcodes=>'none');
DefConstructor('\verb', "<ltx:verbatim font='#font'>#body</ltx:verbatim>",
###	       font=>{family=>'typewriter'},
	       beforeDigest=>[sub { $_[0]->bgroup; MergeFont(family=>'typewriter'); }],
	       afterDigest=>sub { 
		 my($stomach,$whatsit)=@_;
		 $stomach->egroup; 
		 my $font = $whatsit->getFont;
		 my $loc  = $whatsit->getLocator;
		 my $mouth = $stomach->getGullet->getMouth;
		 my ($init,$body);
		 { local $STATE = $EMPTY_CATTABLE;
		   $init = $mouth->readToken;
		   $init = $mouth->readToken if $init->toString eq '*'; # Should I bother handling \verb* ?
		   $body = $mouth->readTokens($init); }
		 $whatsit->setBody(map(LaTeXML::Box->new($_->toString,$font,$loc,$_),$body->unlist,$init)); },
	       reversion=>sub { (T_CS('\verb'),$_[0]->getTrailer->revert,
				 $_[0]->getBody->revert,$_[0]->getTrailer->revert); }
);

# This is defined by the alltt package.
# Environment('alltt', ?);

#**********************************************************************
# C.7 Mathematical Formulas
#**********************************************************************

#======================================================================
# C.7.1 Math Mode Environments
#======================================================================
DefEnvironment('{displaymath}', 
	       "<ltx:equation>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       mode=>'display_math');
DefEnvironment('{math}',
	       "<ltx:Math mode='inline'>"
	       . "<ltx:XMath>"
	       .  "#body"
	       . "</ltx:XMath>"
	       ."</ltx:Math>",
	       mode=>'inline_math');
DefEnvironment('{equation}',
	       "<ltx:equation id='#id' refnum='#refnum'>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       mode=>'display_math',
	       properties=> sub { refStepCounter('equation') });
DefEnvironment('{equation*}',
	       "<ltx:equation id='#id'>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       mode=>'display_math',
	       properties=> sub { refStepID('equation') });

# NOTE: This has to interact with equation to CANCEL (or backtrack?) the
# numbering?
DefPrimitive('\nonumber',undef);

# Define \( ..\) and \[ ... \] to act like environments.
DefConstructor('\[',
	       "<ltx:equation id='#id'>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       beforeDigest=> sub{ $_[0]->beginMode('display_math'); },
	       captureBody=>1,
	       properties=> sub { refStepID('equation') });
DefConstructor('\]'  ,"",beforeDigest=> sub{ $_[0]->endMode('display_math'); });
DefConstructor('\(' ,
	       "<ltx:Math mode='inline'>"
	       . "<ltx:XMath>"
	       .  "#body"
	       . "</ltx:XMath>"
	       ."</ltx:Math>",
	       beforeDigest=> sub{ $_[0]->beginMode('inline_math'); },
	       captureBody=>1);
DefConstructor('\)'   ,"", beforeDigest=> sub{ $_[0]->endMode('inline_math'); });

DefExpandable('\ensuremath{}', sub {
  my($gullet,$stuff)=@_;
  if(LookupValue('IN_MATH')){ @$stuff; }
  else { (T_MATH,@$stuff,T_MATH); }});

# NOTE: Implement these
# Environment('eqnarray' ...
# Environment('eqnarray*' ...

# NOTE: The numbering isn't right.
# And the parseability will have to be worked on!
DefEnvironment('{eqnarray}',
	       sub { 
		 my($document,%props)=@_;
		 $document->openElement('ltx:equation',refnum=>'#refnum', id=>'#id');
		 $document->openElement('ltx:Math',mode=>'display');
		 $document->openElement('ltx:XMath');
		 matharray($document,$props{body},'', 'Matrix','Row','Cell');
		 $document->closeElement('ltx:XMath');
		 $document->closeElement('ltx:Math');
		 $document->closeElement('ltx:equation'); },
	       mode=>'display_math',
	       properties=> sub { refStepCounter('equation') },
	       beforeDigest=>\&before_matharray, afterDigest=>\&after_matharray);
DefEnvironment('{eqnarray*}',
	       sub { 
		 my($document,%props)=@_;
		 $document->openElement('ltx:equation', id=>'#id');
		 $document->openElement('ltx:Math',mode=>'display');
		 $document->openElement('ltx:XMath');
		 matharray($document,$props{body},'', 'Matrix','Row','Cell');
		 $document->closeElement('ltx:XMath');
		 $document->closeElement('ltx:Math');
		 $document->closeElement('ltx:equation'); },
	       mode=>'display_math',
	       properties=> sub { refStepID('equation') },
	       beforeDigest=>\&before_matharray, afterDigest=>\&after_matharray);

# Style Parameters
#  \abovedisplayskip \abovedisplayshortskip, \jot are in Primitives.pm
DefRegister('\mathindent' =>Dimension(0)); 

#======================================================================
# C.7.2 Common Structures
#======================================================================
# sub, superscript and prime are in Primitives.pm

# Ugh; my state keeping is kinda messed up.
# The extra grouping is because the frac itself shoul get the current math style
# but the numerator & denomintor should get a smaller math style!
our %fracstylemap=(display=>'text', text=>'script',
		   script=>'scriptscript', scriptscript=>'scriptscript');
sub beforeFrac { $_[0]->bgroup; AssignValue(mathstyle=>$fracstylemap{LookupValue('mathstyle')}); }
sub afterFrac  { $_[0]->egroup; $_[1]->setProperty('style',LookupValue('mathstyle')); }
DefMath('\frac{}{}','/', name=>"/", operator_role=>'MULOP',
	beforeDigest=>\&beforeFrac, afterDigest =>\&afterFrac);

DefConstructor('\sqrt[]{}',
	       "?#1(<ltx:XMApp><ltx:XMTok name='root'/><ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg></ltx:XMApp>)"
	         ."(<ltx:XMApp><ltx:XMTok name='sqrt'/><ltx:XMArg>#2</ltx:XMArg></ltx:XMApp>)");

# Ellipsis: See Primitives

#======================================================================
# C.7.3 Mathematical Symbols
#======================================================================
# See Tables 3.3 through 3.8 (pp 41--44)
# Defined in Primitives.pm
# [Possibly some are strictly LaTeX and should be moved here?]


#======================================================================
# Modulo

DefMath('\pmod{}', '(\textrm{mod} #1)', role=>'MODIFIER');
DefMath('\bmod',   'mod', role=>'MODIFIEROP');

#======================================================================
# C.7.4 Arrays
#======================================================================
#  See Section C.10.2

#======================================================================-
# C.7.5 Delimiters
#======================================================================-
# All this is already in Primitives.pm

DefConstructor('\stackrel{}{}',
	       "<ltx:XMApp role='RELOP'>"
	       .  "<ltx:XMTok name='Superscript'/>"
	       .  "<ltx:XMWrap stackscripts='yes'>#2</ltx:XMWrap>"
	       .  "<ltx:XMWrap>#1</ltx:XMWrap>"
	       ."</ltx:XMApp>");
#======================================================================-
# C.7.6 Putting One Thing Above Another
#======================================================================-
# All this is already in Primitives.pm

#======================================================================-
# C.7.7 Spacing
#======================================================================-
# All this is already in Primitives.pm

#======================================================================
# C.7.8 Changing Style
#======================================================================
# For Math style changes, we record the current font, which is then merged
# into the Whatsit's created for letters, etc.  The merging depends on
# the type of letter, greek, symbol, etc.
# Apparently, with the normal TeX setup, these fonts don't really merge,
# rather they override all of family, series and shape.

DefConstructor('\mathrm{}', '#1',  bounded=>1, requireMath=>1, font=>{family=>'serif'});
DefConstructor('\mathit{}',  '#1', bounded=>1, requireMath=>1, font=>{shape=>'italic'});
DefConstructor('\mathbf{}',  '#1', bounded=>1, requireMath=>1, font=>{series=>'bold'});
DefConstructor('\mathsf{}',  '#1', bounded=>1, requireMath=>1, font=>{family=>'sansserif'});
DefConstructor('\mathtt{}',  '#1', bounded=>1, requireMath=>1, font=>{family=>'typewriter'});
DefConstructor('\mathcal{}', '#1', bounded=>1, requireMath=>1, font=>{family=>'caligraphic'});
DefConstructor('\mathscr{}', '#1', bounded=>1, requireMath=>1, font=>{family=>'script'});

#**********************************************************************
# C.8 Definitions, Numbering and Programming
#**********************************************************************

#======================================================================
# C.8.1 Defining Commands
#======================================================================

DefPrimitive('\newcommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  Fatal(Stringify($cs)." is already defined") if LookupDefinition($cs);
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

DefPrimitive('\renewcommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

DefPrimitive('\providecommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  return if LookupDefinition($cs);
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

# Need to figure out exactly what `robust' means to LaTeXML...
DefPrimitive('\DeclareRobustCommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  return if LookupDefinition($cs);
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

#======================================================================
# C.8.2 Defining Environments
#======================================================================
# Note that \env & \endenv defined by \newenvironment CAN be 
# invoked directly.

DefPrimitive('\newenvironment OptionalMatch:* {}[][]{}{}', sub {
  my($stomach,$star,$name,$nargs,$opt,$begin,$end)=@_;
  $name = $name->toString;
  Fatal("Environment $name is already defined") if LookupDefinition(T_CS("\\$name"));
  DefMacro(join('','\\',$name, convertLaTeXArgs($nargs,$opt)),$begin);
  DefMacro(join('','\\end',$name),$end); });

DefPrimitive('\renewenvironment OptionalMatch:* {}[][]{}{}', sub {
  my($stomach,$star,$name,$nargs,$opt,$begin,$end)=@_;
  $name = $name->toString;
  DefMacro(join('','\\',$name, convertLaTeXArgs($nargs,$opt)),$begin);
  DefMacro(join('','\\end',$name),$end); });

#======================================================================
# C.8.3 Theorem-like Environments
#======================================================================
# NOTE: Implement.
#  define a new environment which constructs a theorem ?
# Def('\newtheorem','{}[]{}[]", ....);
# => something like <theorem type="foo"> .. </theorem>

#======================================================================
# C.8.4 Numbering
#======================================================================
# We're attempting to mimic LaTeX's counter mechanisms, while leveraging
# it to add id attributes to the main document structural elements.
# These id's should be both unique, and parallel the visible reference numbers
# (as much as possible).  Also, for consistency, we add id's to unnumbered
# document elements (eg from \section*); this requires an additional counter
# (eg. UNsection) and  mechanisms to track it.

# Defines a new counter named $ctr.
# If $within is defined, $ctr will be reset whenever $within is incremented.
# Keywords:
#  idprefix : specifies a prefix to be used in formatting ID's for document structure elements
#           counted by this counter.  Ie. subsection 3 in section 2 might get: id="S2.SS3"
#   nested : a list of counters that correspond to scopes which are "inside" this one.
#           Whenever any definitions scoped to this counter are deactivated,
#           the inner counter's scopes are also deactivated.
#           NOTE: I'm not sure this is even a sensible implementation,
#           or why inner should be different than the counters reset by incrementing this counter.

sub NewCounter { 
  my($ctr,$within,%options)=@_;
  my $unctr = "UN$ctr";		# UNctr is counter for generating ID's for UN-numbered items.
  DefRegister("\\c\@$ctr",Number(0));
  AssignValue("\\c\@$ctr"=>Number(0),'global');
  AssignValue("\\cl\@$ctr"=>Tokens(),'global');
  DefRegister("\\c\@$unctr",Number(0));
  AssignValue("\\c\@$unctr"=>Number(0),'global');
  AssignValue("\\cl\@$unctr"=>Tokens(),'global');
  AssignValue("\\cl\@$within" =>
	      Tokens(T_CS($ctr),T_CS($unctr),
		     (LookupValue("\\cl\@$within") ? LookupValue("\\cl\@$within")->unlist :())),
	      'global') if $within;
  AssignValue("\\cl\@UN$within" =>
	      Tokens(T_CS($unctr),
		     (LookupValue("\\cl\@UN$within") ? LookupValue("\\cl\@UN$within")->unlist :())),
	      'global') if $within;
  AssignValue('nested_counters_'.$ctr =>$options{nested}) if $options{nested};
  DefMacro("\\the$ctr","\\arabic{$ctr}");
  my $prefix = $options{idprefix};
  if(defined $prefix){
    DefMacro("\\the$ctr\@ID",($within ? "\\the$within\@ID.$prefix\\\@$ctr\@ID" 
			      : "$prefix\\\@$ctr\@ID"));
    DefMacro("\\\@$ctr\@ID","0"); }
  }

sub stepCounter {
  my($ctr)=@_;
  AssignValue("\\c\@$ctr"=>LookupValue("\\c\@$ctr")->add(Number(1)),'global');
  # and reset any within counters!
  if(my $nested = LookupValue("\\cl\@$ctr")){
    foreach my $c ($nested->unlist){
      resetCounter($c->toString); }}
  Expand(T_CS("\\the$ctr")); }

sub refStepCounter {
  my($ctr)=@_;
  my $v = stepCounter($ctr);
  InstallDefinition(LaTeXML::Expandable->new(T_CS("\\\@$ctr\@ID"),undef,
					     Tokens(Explode(LookupValue('\c@'.$ctr)->valueOf))));
  my $id = Expand(T_CS("\\the$ctr\@ID"));
  InstallDefinition(LaTeXML::Expandable->new(T_CS('\@currentlabel'),undef,$v));
  InstallDefinition(LaTeXML::Expandable->new(T_CS('\@currentID'),undef,$id));

  # Any scopes activated for previous value of this counter (& any nested counters) must be removed.
  # This may also include scopes activated for \label
  deactivateCounterScope($ctr);
  # And install the scope (if any) for this reference number.
  AssignValue(current_counter=>$ctr,'local');
  AssignValue('scopes_for_counter:'.$ctr => [$ctr.':'.ToString($v)],'local');
  $STATE->activateScope($ctr.':'.ToString($v));
  (refnum=>$v, id=>$id); }

# For UN-numbered units
sub refStepID {
  my($ctr)=@_;
  my $unctr = "UN$ctr";
  my $v = stepCounter($unctr);
  InstallDefinition(LaTeXML::Expandable->new(T_CS("\\\@$ctr\@ID"),undef,
					     Tokens(T_OTHER('x'),Explode(LookupValue('\c@'.$unctr)->valueOf))));
  my $id = Expand(T_CS("\\the$ctr\@ID"));
  InstallDefinition(LaTeXML::Expandable->new(T_CS('\@currentID'),undef,$id));
  (id=>$id); }

sub deactivateCounterScope {
  my($ctr)=@_;
#  print STDERR "Unusing scopes for $ctr\n";
 if(my $scopes = LookupValue('scopes_for_counter:'.$ctr)){
    map($STATE->deactivateScope($_), @$scopes); }
  foreach my $inner_ctr (@{LookupValue('nested_counters_'.$ctr) || []}){
    deactivateCounterScope($inner_ctr); }}

sub resetCounter {
  my($ctr)=@_;
  AssignValue('\c@'.$ctr => Number(0),'global'); 
  # and reset any within counters!
  if(my $nested = LookupValue("\\cl\@$ctr")){
    foreach my $c ($nested->unlist){
      resetCounter($c->toString); }}
  return;}

# For LaTeX documents, We want id's on para, as well as sectional units.
# However, para get created implicitly on Document construction, rather than
# explicitly during digestion (via a whatsit), we can't use the usual LaTeX counter mechanism.
sub number_para {
  my($document,$node,$whatsit)=@_;
  # Get prefix from first parent with an id.
  my(@parents)=$document->findnodes('ancestor::*[@id]',$node); # find 1st id'd parent.
  my $prefix= (@parents ? $parents[$#parents]->getAttribute('id')."." : '');

  # Get the previous number within parent; Worried about intervening elements around para's, but...
  my(@siblings)=$document->findnodes("preceding-sibling::ltx:para",$node);
  my $n=1;
  $n = $1+1  if(@siblings && $siblings[$#siblings]->getAttribute('id')=~/(\d+)$/);

  $node->setAttribute(id=>$prefix."p$n"); }

Tag('ltx:para',afterOpen=>\&number_para);
 
DefPrimitive('\newcounter{}[]',sub { shift; NewCounter(map($_ && $_->toString,@_)); return;});

DefPrimitive('\setcounter{}{Number}',sub {
  my($stomach,$ctr,$value)=@_;
  $ctr="\\c\@".$ctr->toString;
  AssignValue($ctr=>$value,'global');
  return});

DefPrimitive('\addtocounter{}{Number}',sub {
  my($stomach,$ctr,$value)=@_;
  $ctr="\\c\@".$ctr->toString;
  AssignValue($ctr=>LookupValue($ctr)->add($value),'global'); });

DefPrimitive('\stepcounter{}',   sub { stepCounter($_[1]->toString); return; });
DefPrimitive('\refstepcounter{}',sub { refStepCounter($_[1]->toString); return; });

DefExpandable('\value{}', sub {
  Explode(LookupValue('\c@'.$_[1]->toString)->valueOf);});
DefExpandable('\arabic{}',sub {
  Explode(LookupValue('\c@'.$_[1]->toString)->valueOf); });
DefExpandable('\roman{}', sub {
  roman(LookupValue('\c@'.$_[1]->toString)->valueOf); });
DefExpandable('\Roman{}', sub {
  Roman(LookupValue('\c@'.$_[1]->toString)->valueOf); });
DefExpandable('\alph{}',  sub {
  T_OTHER(chr(LookupValue('\c@'.$_[1]->toString)->valueOf+ord('a')-1));});
DefExpandable('\Alph{}',  sub {
  T_OTHER(chr(LookupValue('\c@'.$_[1]->toString)->valueOf+ord('A')-1));});
our @fnsymbols=("*", "\x{2020}", "\x{2021}", "\x{00A7}", "\x{00B6}",
		"\x{2225}", "**", "\x{2020}\x{2020}","\x{2021}\x{2021}");
DefExpandable('\fnsymbol{}',sub { 
		T_OTHER($fnsymbols[LookupValue('\c@'.$_[1]->toString)->valueOf-1]);});

#======================================================================
# C.8.5 The ifthen Package.
#======================================================================
# \ifthenelse
# and sundry conditionals...
#
# Yeah, maybe this'll get done someday....

#**********************************************************************
# C.9 Figures and Other Floating Bodies
#**********************************************************************

#======================================================================
# C.9.1 Figures and Tables
#======================================================================

# Note that, technically, the number is associated with the caption.
# (to allow multiple figures per figure environment?).
# We'll have to sort that out later....
DefConstructor('\caption[]{}',
	       "<ltx:caption>#2</ltx:caption>\n?#1(<ltx:toccaption>#1</ltx:toccaption>)");
DefEnvironment('{figure}[]',
	       "<ltx:figure id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:figure>",
	       properties=> sub { refStepCounter('figure') });
DefEnvironment('{figure*}[]',
	       "<ltx:figure id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:figure>",
	       properties=> sub { refStepCounter('figure') });
DefEnvironment('{table}[]',
	       "<ltx:table id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:table>",
	       properties=> sub { refStepCounter('table')} );
DefEnvironment('{table*}[]',
	       "<ltx:table id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:table>",
	       properties=> sub { refStepCounter('table')} );


DefPrimitive('\suppressfloats[]', undef);

NewCounter('topnumber');
DefMacro('\topfraction',"0.25");
NewCounter('bottomnumber');
DefMacro('\bottomfraction',"0.25");
NewCounter('totalnumber');
DefMacro('\textfraction',"0.25");
DefMacro('\floatpagefraction',"0.25");
NewCounter('dbltopnumber');
DefMacro('\dblfloatpagefraction',"0.25");
DefMacro('\dblfloatpagefraction',"0.25");
DefRegister('\floatsep',Glue(0));
DefRegister('\textfloatsep',Glue(0));
DefRegister('\intextsep',Glue(0));
DefRegister('\dblfloatsep',Glue(0));
DefRegister('\dbltextfloatsep',Glue(0));

#======================================================================
# C.9.2 Marginal Notes
#======================================================================

DefConstructor('\marginpar[]{}', "<ltx:note class='margin'>#2</ltx:note>");
DefPrimitive('\reversemarginpar',undef);
DefPrimitive('\normalmarginpar', undef);
DefRegister('\marginparpush',Dimension(0));

#**********************************************************************
# C.10 Lining It Up in Columns
#**********************************************************************

#======================================================================
# C.10.1 The tabbing Environment
#======================================================================

# NOTE: Do it!!

#======================================================================
# C.10.2 The array and tabular Environments
#======================================================================
# Tabular are a bit tricky in that we have to arrange for tr and td to
# be openned and closed at the right times; the only real markup is
# the & and \\. Also \multicolumn has to be cooperative.
# Along with this, we have to track which column specification applies
# to the current column.
# To simulate LaTeX's tabular borders & hlines, we simply add border
# attributes to all cells.  For HTML, CSS will be necessary to display them.
# [We'll ignore HTML's frame, rules and colgroup mechanisms.]

Tag('ltx:td',afterClose=>\&trimNodeWhitespace);
Tag('ltx:td-between',afterClose=>\&trimNodeWhitespace);

sub tabular {
  my($document,$alignment,$body)=@_;
  # Open the Array, and an initial row and cell.
  local @LaTeXML::TABPATTERN = @{$$alignment{row}};
  local @LaTeXML::TABSPEC = ();
  $document->openElement('ltx:tabular');
  # Start with an open row & column.
  open_tabular_row($document);
  open_tabular_column($document);
  # Now process the body (& and // should be bound to tabular_{align|cr} )
  $document->absorb($body);
  close_tabular_column($document);
  close_tabular_row($document);
  # Since the tabular may or may not have ended with an explicit \\,
  # we need to check for an empty row (w/empty cells), and remove it.
  my $lastrow = $document->getElement->lastChild;
  if(!$document->findnodes('ltx:td[child::* or text()] | ltx:th[child::* or text()]',$lastrow)){
    $lastrow->getParentNode->removeChild($lastrow); } # Loose any embedded comments; Oh well.
  $document->closeElement('ltx:tabular'); }

sub open_tabular_row {
  my($document)=@_;
  $document->openElement('ltx:tr');
###  @LaTeXML::TABSPEC = map( ( {%{$_}} ) , @LaTeXML::TABPATTERN); } # Copy
   @LaTeXML::TABSPEC = ();
  foreach my $col (@LaTeXML::TABPATTERN){ # Copy the specs
    push(@LaTeXML::TABSPEC, { %$col }); }}

sub close_tabular_row {
  my($document)=@_;
  while(@LaTeXML::TABSPEC){	# Pad w/empty cells if needed
    open_tabular_column($document);
    close_tabular_column($document); }
  $document->closeElement('ltx:tr'); }

sub add_tabular_border {
  my($node,@borders)=@_;
  my $border = join(' ',sort(map(split(/ */,$_),$node->getAttribute('border')||'',@borders)));
  $border =~ s/(.) \1/$1$1/g;
  $node->setAttribute(border=>$border) if $border; }

sub open_tabular_column {
  my($document)=@_;
  $document->openElement('ltx:td'); }

sub close_tabular_column {
  my($document)=@_;
  my $node = $document->closeElement('ltx:td');
  my $spec = shift(@LaTeXML::TABSPEC);
  $node->setAttribute(align=>$$spec{align}) if $$spec{align};
  $node->setAttribute(width=>ToString($$spec{width})) if $$spec{width};
  $node->setAttribute(colspan=>$$spec{colspan}) unless ($$spec{colspan}||1) == 1;
  add_tabular_border($node,$$spec{border});
  if(my $after = $$spec{after}){
    $document->insertElement('ltx:td-between',$after); }}

sub tabular_hline {
  my($document,@cols)=@_;
  # We'll already have started the next row (tr+td) when we see this.
  if(my @td = $document->findnodes("parent::ltx:tr/preceding-sibling::*[1][local-name()='tr']/ltx:td",
				   $document->getElement)){
    foreach my $c (@cols){
      my $i=0;
      foreach my $td (@td){
	add_tabular_border($td,'b') if ($i == $c);
	$i +=  $td->getAttribute('colspan')||1; }}}
  else {			# hline before 1st row; save as top for 1st.
    map( $$_{border} .= "t", @LaTeXML::TABSPEC[@cols]); }
}

DefConstructor('\@tabularAlign', sub {
  my($document)=@_;
  if($document->isCloseable('ltx:td')){
    close_tabular_column($document);
    open_tabular_column($document); }
  else { Error("Unable to insert tabular align in unclosed ".$document->getNodePath(4));}},
  beforeDigest=>sub {$_[0]->egroup;}, afterDigest=>sub{$_[0]->bgroup;} );

DefConstructor('\@tabularcr OptionalMatch:* []', sub {
  my($document)=@_;
  if($document->isCloseable('ltx:td','ltx:tr')){
    close_tabular_column($document);
    close_tabular_row($document);
    open_tabular_row($document); 
    open_tabular_column($document); }
  else { Error("Unable to insert tabular cr in unclosed ".$document->getNodePath(4));}},
  beforeDigest=>sub {$_[0]->egroup;}, afterDigest=>sub{$_[0]->bgroup;} );

# The next two can serve as the beforeDigest and afterDigest for array-like environments.
# They set up things for constructing the array, rows and colums.
sub before_tabular {
  Let(T_ALIGN,      T_CS('\@tabularAlign'));
  Let(T_CS("\\\\"), T_CS('\@tabularcr'));
  $_[0]->bgroup; }			# Extra bgroup to prepare for rows & cells

sub after_tabular {
  $_[0]->egroup; }

#======================================================================

DefEnvironment('{tabular}[] TabularPattern',
	       sub { my($document,$pos,$pattern,%props)=@_;
		     tabular($document,$pattern,$props{body}); },
	       beforeDigest=>\&before_tabular, afterDigest=>\&after_tabular,
	       mode=>'text');

DefEnvironment('{tabular*}{}[] TabularPattern', 
	       sub { my($document,$width,$pos,$pattern,%props)=@_;
		     tabular($document,$pattern,$props{body}); },
	       beforeDigest=> \&before_tabular, afterDigest=> \&after_tabular,
	       mode=>'text');


# Open, but don't close, so "&" can operate correctly.
# The td is already open, but we need to replace it's attributes.
DefConstructor('\multicolumn{Number} TabularPattern {}', sub {
  my($document,$ncol,$pattern,$body)=@_;
  # Replace ncol table specs with the new pattern.
  $ncol = $ncol->valueOf;
  my $spec = $$pattern{row}[0];
  $$spec{colspan} = $ncol;
  my $b = $LaTeXML::TABSPEC[0]{border}; # Copy pending top border, if any.
  $b =~ s/[^t]//g;
  $$spec{border} = $b.$$spec{border};
  map(shift(@LaTeXML::TABSPEC), 1..$ncol);
  unshift(@LaTeXML::TABSPEC,$spec);
  $document->absorb($body); });

DefConstructor('\hline',sub {
		 my($document)=@_;
		 tabular_hline($document,0..$#LaTeXML::TABPATTERN); });

DefConstructor('\cline{}', sub {
		 my($document,$cols)=@_;
		 $cols = ToString($cols);
		 my @cols=();
		 while($cols=~ s/^,?(\d+)//){
		   my $n = $1;
		   push(@cols, ($cols =~ s/^-(\d+)// ? ($n-1..$1-1) : ($n-1))); }
		 tabular_hline($document,@cols); });

DefConstructor('\vline',"");	# ???
DefRegister('\arraycolsep',Dimension(0));
DefRegister('\tabcolsep',Dimension(0));
DefRegister('\arrayrulewidth',Dimension(0));
DefMacro('\extracolsep{}','');
DefMacro('\arraystretch',"1");

#======================================================================
# Candidate for Package.pm ?
sub ReadParameters {
  my($gullet,$spec)=@_;
  my $for = T_OTHER("Anonymous");
  my $parm = LaTeXML::Parameters::parseParameters($spec,$for);
  $parm->readArguments($gullet,$for); }

sub ReadTabularPattern {
  my($gullet)=@_;
  my $open = $gullet->readToken;		# Better be {
  my @tokens=($open);
  my @row=();
  my $b='';
  while(my $op = $gullet->readToken){
    last if $op->equals(T_END);
    if($op->equals(T_OTHER('|'))){
      push(@tokens,$op);
      if(@row){
	$row[$#row]{border} .= 'r'; }
      else {
	$b .= 'l'; }}
    elsif($op->equals(T_LETTER('r'))){
      push(@tokens,$op);
      push(@row, {align=>'right', border=>$b}); $b=''; }
    elsif($op->equals(T_LETTER('l'))){
      push(@tokens,$op);
      push(@row, {align=>'left', border=>$b} ); $b=''; }
    elsif($op->equals(T_LETTER('c'))){
      push(@tokens,$op);
      push(@row, {align=>'center', border=>$b} ); $b=''; }
    elsif($op->equals(T_LETTER('p'))){
      my($width) = ReadParameters($gullet,'{Dimension}');
      push(@row, {align=>'justify', width=>$width, border=>$b} );  $b=''; 
      push(@tokens,$op, T_BEGIN,$width->revert,T_END); }
    elsif($op->equals(T_OTHER('*'))){
      my($n,$p)= ReadParameters($gullet,'{Number}{}');
      $n = $n->valueOf;
      for(my $i=0; $i<$n; $i++){
	$gullet->unread($p->unlist); }}
    elsif($op->equals(T_OTHER('@'))){
      # NOTE Special casing: Trim spacing, look for \vline
      my @toks = $gullet->readArg->unlist;
      push(@tokens,$op,@toks);
      while(@toks && $toks[0]->toString =~ /^\\[,:;! ]$/){ shift(@toks); }
      while(@toks && $toks[$#toks]->toString =~ /^\\[,:;! ]$/){ pop(@toks); }
      if(scalar(@toks)==1 && $toks[0]->equals(T_CS('\vline'))){
	shift(@toks); $gullet->unread(T_OTHER('|')); }
      $row[$#row]{after} = Digest(Tokens(@toks)) if @toks; }
    else {
      Warn("Unrecognized tabular pattern \"".Stringify($op)."\""); last; }}
  return LaTeXML::TabularPattern->new(row=>[@row], tokens=>[@tokens]); }

{
package LaTeXML::TabularPattern;
use base qw(LaTeXML::Object);
sub new {
  my($class,%data)=@_;
    bless {%data}, $class; }
sub revert {
  my($self)=@_;
  @{ $$self{tokens} }; }
}

#======================================================================
# Experimental tabular heading heuristications.
#======================================================================
# We attempt to recognize patterns of rows/columns that indicate which might be headers.
# We'll characterize the cells by alignment, content and borders.
# Then, assuming that headers will be first and be noticably `different' from data lines,
# and also that the data lines will have similar structure,  we'll attempt to
# recognize groups of header lines and groups data lines, possibly alternating.

Tag('ltx:tabular', afterClose=>\&guess_tabular_headers);

sub guess_tabular_headers {
  my($document,$tabular)=@_;
  # Assume that headers don't make sense for nested tables.
  # OR Maybe we should only do this within table environments???
  return if $document->findnodes("ancestor::ltx:tabular",$tabular);

  # Build a view of the table by extracting the rows, collecting & characterizing each cell.
  my @rows = collect_tabular_rows($document,$tabular);
  # Flip the rows around to produce a column view.
  my @cols = ();
  for(my $c = 0; $c < scalar(@{$rows[0]}); $c++){
    push(@cols, [map($$_[$c], @rows)]); }
  # Attempt to recognize header lines.
  tabular_characterize_lines(0,@rows);
  tabular_characterize_lines(1,@cols);
  # Regroup the rows into thead & tbody elements.
  tabular_regroup($document,$tabular,@rows);
  # Debugging report!
  summarize_tabular([@rows],[@cols]) if $LaTeXML::Tabular::DEBUG;
}

#======================================================================
# Regroup the rows into thead & tbody
sub tabular_regroup {
  my($document,$tabular,@rows)=@_;
  my ($group,$grouptype)=(undef,0);
  foreach my $xrow ($document->findnodes("ltx:tr",$tabular)){
    my $rowtype = (grep($$_{role} ne 'h', @{ shift(@rows)} ) ? 'tbody' : 'thead');
    if($grouptype ne $rowtype){
      $group = $tabular->addNewChild($xrow->getNamespaceURI, $grouptype = $rowtype);
      $tabular->insertBefore($group,$xrow); }
    $group->appendChild($xrow); }
  }
#======================================================================
# Build a View of the tabular, with characterized cells, for analysis.
sub collect_tabular_rows {
  my($document,$tabular)=@_;
  my @rows = ();
  foreach my $xrow ($document->findnodes("ltx:tr",$tabular)){
    push(@rows, [ ] );
    my $c=0;
    foreach my $xcell ($document->findnodes("ltx:td",$xrow)){
      my $class = classify_tabular_cell($document,$xcell);
      my $align = $xcell->getAttribute('align');
      my %border = (t=>0, r=>0, b=>0, l=>0); # Decode border
      map($border{$_}++, split(/ */,$xcell->getAttribute('border')||''));
      $border{t}=$rows[$#rows-1][$c]{b} if $#rows > 0;	   # Copy prev bottom border to top.
      $border{l}=$rows[$#rows][$c-1]{r} if $c > 0;	   # Copy prev right border to left.
      if (my $colspan = $xcell->getAttribute('colspan')) { # From a multicolumn (> 1)
	for (my $i=0; $i<$colspan; $i++) { # Add colspan cells
	  push(@{$rows[$#rows]},{role=>'d', class=>$class, align=>$align,
				 t=>$border{t}, b=>$border{b}}); }
	# Add left & right borders to first & last spanned cell.
	$rows[$#rows][$c]{cell} = $xcell;
	$rows[$#rows][$c]{l} =  $border{l};
	$rows[$#rows][$c+$colspan-1]{r} =  $border{r};
	$c += $colspan; }
      else {			# Add a regular cell.
	push(@{$rows[$#rows]},{cell=>$xcell, role=>'d', class=>$class, align=>$align,%border});
	$c++; }
    }}
  @rows; }

# Return one of: i(nteger), t(ext), m(ath), ? (unknown) or '_' (empty) (or some combination)
#  or 'mx' for alternating text & math.
sub classify_tabular_cell {
  my($document,$xcell)=@_;
  my $content = $xcell->textContent;
  my $class;
  if($content =~ /^\s*\d+\s*$/){
    $class = 'i'; }
  else {
    foreach my $ch ($xcell->childNodes){
      my $chtype = $ch->nodeType;
      if($chtype == XML_TEXT_NODE){
	my $text = $ch->textContent;
	$class .= 't' 
	  unless $text=~/^\s*$/ || (($class eq 'm') && ($text=~/^\s*[\.,;]\s*$/)); }
      elsif($chtype == XML_ELEMENT_NODE){
	my $chtag = $document->getNodeQName($ch);
	if($chtag eq 'ltx:text'){ # Font would be useful, but haven't "resolved" it, yet!
	  $class .= 't' unless $class eq 't'; }
	elsif($chtag eq 'ltx:Math'){
	  $class .= 'm' unless $class eq 'm'; }
	else {
	  $class .= '?' unless $class; }}}}
  $class = 'mx' if $class && (($class =~ /^((m|i)t)+(m|i)?$/)||($class =~ /^(t(m|i))+t?$/));
  $class || '_'; }

#======================================================================
# Scan pairs of rows/columns attempting to recognize differences that
# might indicate which are headers and which are data.
# Warning: This section is full of "magic numbers"
# guessed by sampling various test cases.

our $MIN_TABULAR_DATA_LINES=1;	#  (or 2?)
our $MAX_TABULAR_HEADER_LINES=4;

# We expect to find header lines at the beginning, noticably different from the eventual data lines.
# But the header lines might be quite similar to each other.  So, the strategy is to look
# for a `hump' in the line differences and consider blocks containing these lines to be potential headers.
sub tabular_characterize_lines {
  my($axis,@lines)=@_;
  my $n = scalar(@lines);
  return unless $n > 1;
  local @::TABLINES = @lines;
  print STDERR "\nCharacterizing $n ".($axis ? "columns" : "rows")."\n   " if $LaTeXML::Tabular::DEBUG;

  # Establish a scale of differences for the table.
  my($diffhi,$difflo)=(0,99999999);
  for(my $l = 0; $l < $n-1; $l++){
    my $d = tabular_compare($axis,1,$l,$l+1);
    $diffhi = $d if $d > $diffhi;
    $difflo = $d if $d < $difflo; }
  print STDERR "Lines are almost identical => Fail\n" if $diffhi < 0.05 && $LaTeXML::Tabular::DEBUG;
  return if $diffhi < 0.05;	# virtually no differences.
#  local $::TAB_THRESHOLD = $difflo + 0.4*($diffhi-$difflo);
  local $::TAB_THRESHOLD = $difflo + 0.2*($diffhi-$difflo);
  local $::TAB_AXIS = $axis;
  print STDERR "\Differences $difflo -- $diffhi => threshold = $::TAB_THRESHOLD\n" if $LaTeXML::Tabular::DEBUG;
  # Find the first hump in differences. These are candidates for header lines.
  print STDERR "Scanning for headers\n   " if $LaTeXML::Tabular::DEBUG;
  my $diff;
  my ($minh,$maxh) = (1,1);
  while( ($diff=tabular_compare($axis,1,$maxh-1,$maxh)) < $::TAB_THRESHOLD){
    $maxh++; }
  while( tabular_compare($axis,1,$maxh,$maxh+1) > $difflo + ($diff-$difflo)/6){
    $maxh++; }
  $maxh = $MAX_TABULAR_HEADER_LINES if $maxh > $MAX_TABULAR_HEADER_LINES;
 print STDERR "\nFound from $minh--$maxh potential headers\n" if $LaTeXML::Tabular::DEBUG;

  my $nn = scalar(@{$lines[0]})-1;
  # Now, change all cells marked as header from td => th.
  for(my $nh = $maxh; $nh >= $minh; $nh--){
#  for(my $nh = $minh; $nh <= $maxh; $nh++){
    if(my @heads = tabular_test_headers($nh)){
      foreach my $h (@heads){
	my $i = 0;
	foreach my $cell (@{$lines[$h]}){
	  $$cell{role} = 'h';
	  if(my $xcell = $$cell{cell}){
	    if(($$cell{class} eq '_') # But NOT empty cells on outer edges.
	       && (( ($i==0) && !$$cell{($axis==0 ? 'l' : 't')} )
		   ||(($i==$nn) && !$$cell{($axis == 0 ? 'r' : 'b')}))){}
	    else {
	      # Rename td => th (by remaking the node)
	      my $newNode = $xcell->parentNode->addNewChild($xcell->getNamespaceURI,'th');
	      map($newNode->appendChild($_),$xcell->childNodes);
	      foreach my $attribute ($xcell->attributes){
		$newNode->setAttribute($attribute->nodeName,$attribute->getValue); }
	      $xcell->replaceNode($newNode);
	      $$cell{cell} = $newNode; }}
	  $i++; }}
      last; }}
  1; }

# Test whether $nhead lines makes a good fit for the headers
sub tabular_test_headers {
  my($nhead)=@_;
  print STDERR "Testing $nhead headers\n" if $LaTeXML::Tabular::DEBUG;
  my @heads =(0..$nhead-1);		# The indices of heading lines.
  my $i = $nhead;		# Start from the end of the proposed headings.
  # Watch out for the assumed header being really data that is a repeated pattern.
  my $nrep = scalar(@::TABLINES)/$nhead;
  if(($nhead > 1) && ($nrep == int($nrep))){
    print STDERR "Check for apparent header repeated $nrep times\n" if $LaTeXML::Tabular::DEBUG;
    my $matched = 1;
    for(my $r = 1; $r < $nrep; $r++){
      $matched &&= tabular_match_head(0,$r*$nhead,$nhead); }
    print STDERR "Repeated headers: ".($matched ? "Matched=> Fail" : "Nomatch => Succeed")."\n" if $LaTeXML::Tabular::DEBUG;
    return if $matched; }

  # And find a following grouping of data lines.
  my $ndata = tabular_skip_data($i);
  return unless $ndata >= $nhead; # ???? Well, maybe if _really_ convincing???
  return unless ($ndata >= $nhead) || ($ndata >= 2);
  $i += $ndata;
  my $nd;
  # If there are more lines, they should match either the previous data block, or the head/data pattern.
  while($i < scalar(@::TABLINES)){
    # First try to match a repeat of the 1st data block; 
    # This would be the case when groups of data have borders around them.
    # Could conceivably wnat to match a variable number of datalines, but they should be similar!!!??!?!?

    if(($ndata > 1) && ($nd = tabular_match_data($nhead,$i,$ndata))){
      $i += $nd; }
      # Else, try to match the first header block; less common.
    elsif(tabular_match_head(0,$i,$nhead)){
      push(@heads,$i..$i+$nhead-1);
      $i += $nhead;
      # Then attempt to match a new data block.
#      my $d = tabular_skip_data($i);
#      return unless ($d >= $nhead) || ($d >= 2);
#      $i += $d; }
      # No, better be the same data block?
      return unless ($nd = tabular_match_data($nhead,$i,$ndata));
      $i += $nd; }
    else { return; }}
   print STDERR "Succeeded with $nhead headers\n" if $LaTeXML::Tabular::DEBUG;
  @heads; }

sub tabular_match_head {
  my($p1,$p2,$nhead)=@_;
  print STDERR "Try match $nhead header lines from $p1 to $p2\n   " if $LaTeXML::Tabular::DEBUG;
  my $nh = tabular_match_lines($p1,$p2,$nhead);
  my $ok = $nhead == $nh;
  print STDERR "\nMatched $nh header lines => ".($ok ? "Succeed" : "Failed")."\n" if $LaTeXML::Tabular::DEBUG;
  ($ok ? $nhead : 0); }

sub tabular_match_data {
  my($p1,$p2,$ndata)=@_;
  print STDERR "Try match $ndata data lines from $p1 to $p2\n   " if $LaTeXML::Tabular::DEBUG;
  my $nd = tabular_match_lines($p1,$p2,$ndata);
  my $ok = ($nd*1.0)/$ndata  > 0.66;
  print STDERR "\nMatched $nd data lines => ".($ok ? "Succeed" : "Failed")."\n" if $LaTeXML::Tabular::DEBUG;
  ($ok ? $nd : 0); }

# Match the $n lines starting at $i2 to those starting at $i1.
sub tabular_match_lines {
  my($p1,$p2,$n)=@_;
  for(my $i = 0; $i < $n; $i++){
    return $i if ($p1+$i >= scalar(@::TABLINES)) || ($p2+$i >= scalar(@::TABLINES))
      || tabular_compare($::TAB_AXIS,0, $p1+$i, $p2+$i) >= $::TAB_THRESHOLD; }
  return $n; }

# Skip through a block of lines starting at $i that appear to be data, returning the number of lines.
# We'll assume the 1st line is data, compare it to following lines,
# but also accept `continuation' data lines.
sub tabular_skip_data {
  my($i)=@_;
  return 0 if $i >= scalar(@::TABLINES);
  print STDERR "Scanning for data\n   " if $LaTeXML::Tabular::DEBUG;
  my $n = 1;
  while($i+$n < scalar(@::TABLINES)){
    last unless (tabular_compare($::TAB_AXIS,1, $i+$n-1, $i+$n) < $::TAB_THRESHOLD)
      # Accept an outlying `continuation line' as data, if mostly empty
      || (($n > 1) && (scalar(grep($$_{class} eq '_', @{$::TABLINES[$i+$n]})) > 0.4*scalar($::TABLINES[0])));
    $n++; }
  print STDERR "\nFound $n data lines at $i\n" if $LaTeXML::Tabular::DEBUG;
  ($n >= $MIN_TABULAR_DATA_LINES ? $n : 0); }

#======================================================================
# The comparator.
our %cell_class_diff =
  ('_'=>{'_'=>0.0, m=>0.1, i=>0.1, t=>0.1, '?'=>0.1, mx=>0.1},
   m  =>{'_'=>0.1, m=>0.0, i=>0.1, mx=>0.2},
   i  =>{'_'=>0.1, m=>0.1, i=>0.0, mx=>0.2},
   t  =>{'_'=>0.1, t=>0.0, mx=>0.2},
   '?'=>{'_'=>0.1, '?'=>0.0, mx=>0.2},
   mx=>{'_'=>0.1, m=>0.2, i=>0.2, t=>0.2, '?'=>0.2, mx=>0.0});

# Compare two lines along $axis (0=row,1=column), returning a measure of the difference.
# The borders are compared differently if
#  $foradjacency: we adjacent lines that might belong to the same block,
#  otherwise    : comparing two lines that ought to have identical patterns (eg. in a repeated block)
sub tabular_compare {
  my($axis, $foradjacency, $p1,$p2)=@_;
  my $line1 = $::TABLINES[$p1];
  my $line2 = $::TABLINES[$p2];
  return 0 if !($line1 && $line2);
  return 999999 if $line1 xor $line2;
  my @cells1 = @$line1;
  my @cells2 = @$line2;
  my $diff=0.0;
  while(@cells1 && @cells2){
    my $cell1 = shift(@cells1);
    my $cell2 = shift(@cells2);
    $diff += 0.5 if ($$cell1{align} ne $$cell2{align});
    if(my $d = $cell_class_diff{$$cell1{class}}{$$cell2{class}}){
      $diff += $d; }
    elsif($$cell1{class} ne $$cell2{class}){
      $diff += 0.75; }
    # compare certain edges
    if($foradjacency){		# Compare edges for adjacent rows of potentially different purpose
      $diff += 0.3*scalar(grep($$cell1{$_} != $$cell2{$_}, ($axis == 0 ? qw(r l) : qw(t b))));
      my $pedge  = ($axis == 0 ? 'b' : 'r');
      my $pother = ($axis == 0 ? 't' : 'l');
      # Penalty for apparent divider between.
      $diff += 2.0*$$cell1{$pedge}
	unless ($$cell1{$pedge} == $$cell1{$pother}) && ($$cell1{$pedge} == $$cell2{$pedge});
    }
    else {			# Compare edges for rows from diff places for potential similarity
      $diff += 0.3*scalar(grep($$cell1{$_} != $$cell2{$_}, qw(r l t b))); }
  }
  $diff /= scalar(@$line1);
  print STDERR "$p1-$p2 => $diff; " if $LaTeXML::Tabular::DEBUG;
  return $diff; }

#======================================================================
# Debugging.
sub summarize_tabular {
  my($rows,$cols)=@_;
  my $r=0;
  my %acode = (right=>'r', left=>'l', center=>'c', justify=>'p');
  my ($nrows,$ncols) = (scalar(@$rows),scalar(@{$$rows[0]}));
  print STDERR "\n";
  foreach my $cell (@{$$rows[0]}){
    print STDERR ' '.($$cell{t} ? ('-' x 6) : (' ' x 6)); }
  print STDERR "\n";
  foreach my $row (@$rows){
    my $maxb = 0;
    print STDERR ($$row[0]{l} ? ('|' x $$row[0]{l}) : ' ');
    foreach my $cell (@$row){
      print STDERR sprintf(" %4s ",$$cell{role}.$acode{$$cell{align}}.$$cell{class}).
	($$cell{r} ? ('|' x $$cell{r}) : ' ');
      $maxb = $$cell{b} if $$cell{b} > $maxb; }
#    print STDERR sprintf("%.3f",tabular_compare(0,1,$$rows[$r],$$rows[$r+1])) if ($r < $nrows-1);
    print STDERR "\n";
    for(my $b = 0; $b < $maxb; $b++){
      foreach my $cell (@$row){
	print STDERR ' '.($b < $$cell{b} ? ('-' x 6) : (' ' x 6)); }
      print STDERR "\n"; }
    $r++; }
  print STDERR "   ";
#  for(my $c = 0; $c < $ncols-1; $c++){
#    print STDERR sprintf(" %.3f ",tabular_compare(1,1,$$cols[$c],$$cols[$c+1])); }
  print STDERR "\n";
}

#======================================================================

#======================================================================
# Array and similar environments
# Since in Math, we're using XMTok and XMApp generically, rather than specific <tr>,<td> etc.
# we have to do all the `automatic' open/close manually.
sub matharray {
  my($document,$body,$colspec,$arrayname,$rowname,$cellname, %attributes)=@_;
  local($LaTeXML::arrayname,$LaTeXML::rowname,$LaTeXML::cellname)=($arrayname,$rowname,$cellname);
  # Open the Array, and an initial row and cell.
  open_matharray_level($document,$arrayname,%attributes);
  open_matharray_level($document,$rowname);
  open_matharray_level($document,$cellname);
  open_matharray_arg($document);
  # Now process the body (& and // should be bound to matharray_{align|cr} )
  $document->absorb($body);
  # Close open cell and row, pruning empty ones.
  close_matharray_arg($document);
  close_matharray_level($document,$cellname,1);
  close_matharray_level($document,$rowname,1);
  close_matharray_level($document,$arrayname,0);
}

# Close XMArg, and if empty, remove it.
sub open_matharray_arg {
  my($document)=@_;
  # NOTE: Until this gets better sorted out, allow punctuation!
  $document->openElement('ltx:XMArg',rule=>'Anything,'); }

sub close_matharray_arg {
  my($document)=@_;
  my $node = $document->closeElement('ltx:XMArg');
  # If XMArg is (except for comments) empty, remove it, but move it's comments up.
  if(grep($_->nodeType != XML_COMMENT_NODE, $node->childNodes) == 0){ # No non-comment => `empty'
    $node->getParentNode->removeChild($node);
    map($node->getParentNode->appendChild($_),
	grep($_->nodeType == XML_COMMENT_NODE, $node->childNodes)); }
}

sub open_matharray_level {
  my($document,$levelname,%attributes)=@_;
  $document->openElement('ltx:XMApp',role=>'ARRAY'); # Is this right?
  $document->insertElement('ltx:XMTok',undef,name=>$levelname,%attributes); }

sub close_matharray_level {
  my($document,$levelname,$prune)=@_;
  # If XMApp is empty (except for the Array/Row/Cell operator and comments), remove it,
  # but preserve the commetns.
  my $node = $document->closeElement('ltx:XMApp');
  if(grep($_->nodeType != XML_COMMENT_NODE, $node->childNodes) == 1){ # Only 1 non-comment => `empty'
    $node->getParentNode->removeChild($node);
    map($node->getParentNode->appendChild($_),
	grep($_->nodeType == XML_COMMENT_NODE, $node->childNodes)); }
}

# Note: The next two worry me abit.
#  If we're in the middle of something `important', particularly something
# that can't be broken, when a & or \\ appears, it may be preferable
# to ignore the & or \\ and continue.  The table/array structure won't end
# up right, but...
sub matharray_align {
  my($document)=@_;
  my $n;
  # Convoluted: "Do we seem to be in the right place?"
  if(($n=$document->isCloseable('ltx:XMArg','ltx:XMApp'))
      && ($n = $n->firstChild) && (($n->getAttribute('name')||'') eq $LaTeXML::cellname)){
    close_matharray_arg($document);
    close_matharray_level($document,$LaTeXML::cellname);
    open_matharray_level($document,$LaTeXML::cellname);
    open_matharray_arg($document); }
  else { Error("Unable to insert array align in unclosed ".$document->getNodePath(4));}
}

sub matharray_cr {
  my($document)=@_;
  my $n;
  # Convoluted: "Do we seem to be in the right place?"
  if(($n=$document->isCloseable('ltx:XMArg','ltx:XMApp','ltx:XMApp'))
      && ($n = $n->firstChild) && (($n->getAttribute('name')||'') eq $LaTeXML::rowname)){
    close_matharray_arg($document);
    close_matharray_level($document,$LaTeXML::cellname,1);
    close_matharray_level($document,$LaTeXML::rowname);
    open_matharray_level($document,$LaTeXML::rowname);
    open_matharray_level($document,$LaTeXML::cellname);
    open_matharray_arg($document); }
  else { Error("Unable to insert array cr in unclosed ".$document->getNodePath(4));}
}


# The next two can serve as the beforeDigest and afterDigest for array-like environments.
# They set up things for constructing the array, rows and colums.
sub before_matharray {
  DefConstructor('&', \&matharray_align,
		 beforeDigest=>sub {$_[0]->egroup;}, afterDigest=>sub{$_[0]->bgroup;} );
  DefConstructor("\\\\ OptionalMatch:* []", \&matharray_cr,
		 beforeDigest=>sub {$_[0]->egroup;}, afterDigest=>sub{$_[0]->bgroup;} );
  # Hmm... So, if we've got \hlines, it's more like a table than a matrix,....
  DefConstructor('\hline',"<ltx:XMHint name='hline'/>");
  $_[0]->bgroup; }

sub after_matharray {
  $_[0]->egroup; }

DefEnvironment('{array}[]{}',sub { my($document,$pos,$alignment,%props)=@_;
				   matharray($document,$props{body},$alignment,'Array','Row','Cell'); },
	       beforeDigest=>\&before_matharray, afterDigest=>\&after_matharray);

#**********************************************************************
# C.11 Moving Information Around
#**********************************************************************

#======================================================================
# C.11.1 Files
#======================================================================
DefPrimitive('\nofiles',undef);

#======================================================================
# C.11.2 Cross-References
#======================================================================

# \label attaches a label to the nearest parent that can accept a label attribute
DefConstructor('\label Semiverbatim',
	       "^ label='#1'",
	       reversion=>'',
	       afterDigest=>sub {
		 my $label = $_[1]->getArg(1)->toString;
		 my $scope = 'label:'.$label;
		 if(my $ctr = LookupValue('current_counter')){
		   unshift(@{LookupValue('scopes_for_counter:'.$ctr)},$scope);
		   $STATE->activateScope($scope);
		   $_[0]->beginMode('text');
		   AssignValue('LABEL@'.$label, Digest(T_CS('\@currentlabel')),'global');
		   $_[0]->endMode('text'); }
		 return; });

DefConstructor('\ref Semiverbatim', "<ltx:ref labelref='#1'>&LookupValue('LABEL@#1')</ltx:ref>");
DefConstructor('\pageref Semiverbatim', "<ltx:ref labelref='#1'>&LookupValue('LABEL@#1')</ltx:ref>"); # Same??
#======================================================================
# C.11.3 Bibliography and Citation
#======================================================================

# NOTE: Not really complete, since I haven't dealt with bibliographies!
DefConstructor('\bibliography{}',
	       "<ltx:bibliography files='#1'/>");

DefEnvironment('{thebibliography}{}',
	       "<ltx:bibliography>"
	       . "<ltx:title>References</ltx:title>"
	       . "<ltx:biblist>#body</ltx:biblist>"
	       ."</ltx:bibliography>");

# NOTE: 
DefConstructor('\bibitem[]{}',
	       "<ltx:bibitem key='#2'>?#1(<ltx:biblabel>#1</ltx:biblabel>)<ltx:bibblock>");
DefConstructor('\newblock',"<ltx:bibblock>");
Tag('ltx:bibitem', autoClose=>1);
Tag('ltx:bibblock', autoClose=>1);

sub makecite {
  my($style,$show, $document,$phrase1,$phrase2,$ref)=@_;
  $document->openElement('ltx:cite', ref=>$ref,style=>$style, show=>$show);
  if(defined $phrase1 && defined $phrase2){
    $document->insertElement('ltx:citepre',$phrase1);
    $document->insertElement('ltx:citepost',$phrase2); }
  elsif(defined $phrase1){
    $document->insertElement('ltx:citepost',$phrase1); }
  $document->closeElement('ltx:cite'); }

# Most of this is really natbib style.
DefConstructor('\cite[][] Semiverbatim',       sub { makecite('parenthetic','all',@_); });
DefConstructor('\citet[][] Semiverbatim',      sub { makecite('intext','all',@_); });
DefConstructor('\citep[][] Semiverbatim',      sub { makecite('parenthetic','all',@_); });
DefConstructor('\citeauthor[][] Semiverbatim', sub { makecite('intext','author',@_); });
DefConstructor('\citeyear[][] Semiverbatim',   sub { makecite('intext','year',@_); });
DefConstructor('\citeyearpar[][] Semiverbatim',sub { makecite('parenthetic','year',@_); });


#======================================================================
# C.11.4 Splitting the input
#======================================================================
# LaTeX's \input is a bit different...
DefPrimitive('\input', sub {
  my($stomach)=@_;
  my $gullet=$stomach->getGullet;
  my $file;
  if($gullet->ifNext(T_BEGIN)){ # Read LaTeX style
    $file=Expand($gullet->readArg); }
  else {			# Read TeX style.
    my ($token,@tokens)=();
    while(($token = $gullet->readXToken) && ($token->getCatcode != CC_SPACE)){
      push(@tokens,$token); }
    $file = Tokens(@tokens); }
  $gullet->input($file,['tex','']);
  return; });

# Note that even excluded files SHOULD have the effects of their inclusion
# simulated by having read the corresponding aux file;
# But we're not bothering with that.
DefPrimitive('\include{}',sub { 
  my($stomach,$file)=@_;
  $file = $file->toString;
  my $table = LookupValue('including@only');
  $stomach->getGullet->input($file,['tex','']) if !$table || $$table{$file};
  return;});

DefPrimitive('\includeonly{}',sub {
  my($stomach,$files)=@_;
  $files = $files->toString;
  my $table = LookupValue('including@only');
  AssignValue('including@only', $table = {}, 'global') unless $table;
  map( $$table{$_}=1, split(',',$files));
  return; });

#Environment('filecontents','{}',?
#Environment('filecontents*','{}',?

DefPrimitive('\listfiles',undef);

#======================================================================
# C.11.5 Index and Glossary
#======================================================================
DefEnvironment('{theindex}', "<ltx:theindex>#body</ltx:theindex>");
DefPrimitive('\printindex',  undef);
DefPrimitive('\makeindex',   undef);
DefPrimitive('\makeglossary',undef);

# Format of Index entries:
#   \index{entry!entry}  gives multilevel index (handled)
# Each entry:
#   foo@bar  sorts on "foo" but prints "bar" (not handled yet)
# The entries can end with a |expression:
#   \index{...|(}    this page starts a range for foo (not handled)
#   \index{...|)}    this page ends a range (not handled)
#   \index{...|see{key}}  cross reference (not handled yet)
#      [I think makeindex just prints key, but we'll have to create an actual cross link!!!]
#   \index{...|textbf}  (etc) causes the number to be printed in bold!
#
# I guess the formula is that
#    \index{foo!whatever{pi}{pa}{po}}  => \whatever{pi}{pa}{po}{page}
# How should this get interpreted??

# A bit screwy, but....
# Expand \index{a!b!...} into \@index{\@indexphrase{a}\@indexphrase{b}...}
sub process_index_phrases {
  my($gullet,$phrases)=@_;
  my @expansion = (T_CS('\@index'),T_BEGIN);
  # Split the text into phrases, separated by "!"
  my @tokens = $phrases->unlist;
  push(@tokens,T_OTHER('!')) unless $tokens[$#tokens]->getString eq '!'; # Add terminal !
  my @phrase=();
  foreach my $tok (@tokens){
    if($tok->getString eq '!'){
      while(@phrase && ($phrase[$#phrase]->getString =~ /\s/)){ pop(@phrase); }
      push(@expansion,T_CS('\@indexphrase'),T_BEGIN,@phrase,T_END)
	if @phrase;
      @phrase=(); }
    elsif(!@phrase && ($tok->getString =~ /\s/)){}	# Skip leading whitespace
    else { 
      push(@phrase,$tok); }}
  push(@expansion,T_END);
  @expansion; }

DefExpandable('\index{}', \&process_index_phrases);

DefConstructor('\@index{}',"^<ltx:index>#1</ltx:index>", mode=>'text', reversion=>'');
DefConstructor('\@indexphrase{}',"<ltx:indexphrase>#1</ltx:indexphrase>");

# NOTE:
# DefConstructor('\glossary','{}',sub { ...
#======================================================================
# C.11.6 Terminal Input and Output
#======================================================================

DefPrimitive('\typeout{}',sub {
  my($stomach,$stuff)=@_;
  print STDERR ToString(Expand($stuff));
  return; });

#DefPrimitive('\typein[]{}',sub {
#  print STDERR ToString($_[2]); 
#  # Then setValue $_[1] to read ???
#	       });

#**********************************************************************
# C.12 Line and Page Breaking
#**********************************************************************

#======================================================================
# C.12.1 Line Breaking
#======================================================================
DefPrimitive('\linebreak[]',undef);
DefPrimitive('\nolinebreak[]',undef);
# \\ already defined
DefConstructor('\newline',"\n");
DefPrimitive('\-',undef);	# We don't do hyphenation.
# \hyphenation in Primitives.pm

DefPrimitive('\sloppy',undef);
DefPrimitive('\fussy',undef);

#======================================================================
# C.12.2 Page Breaking
#======================================================================
DefPrimitive('\pagebreak[]',undef);
DefPrimitive('\nopagebreak[]',undef);
DefPrimitive('\enlargethispage OptionalMatch:* {}',undef);

DefPrimitive('\clearpage',undef); # Could possibly mean something?
DefPrimitive('\cleardoublepage',undef);

#**********************************************************************
# C.13 Lengths, Spaces and Boxes
#**********************************************************************

#####
#####
#  Complete to here
#  [except for NOTE'd entries, of course]
#####
#####

#======================================================================
# C.13.1 Length
#======================================================================
# \fill
# \stretch
# \newlength{cmd}
DefPrimitive('\newlength{Token}',sub {
  my($stomach,$cmd)=@_;
  DefRegister($cmd->toString,Dimension(0)); });
# \setlength{cmd}{len}
DefPrimitive('\setlength{Token}{Dimension}',sub{
  my($stomach,$cmd,$dimen)=@_;
  LookupDefinition($cmd)->setValue($dimen);});
# \addtolength{cmd}{len}
DefPrimitive('\addtolength{Token}{Dimension}',sub{
  my($stomach,$cmd,$dimen)=@_;
  my $register =  LookupDefinition($cmd);
  $register->setValue($register->valueOf->add($dimen));});
# \settowidth{cmd}{text}
# \settoheight{cmd}{text}
# \settodepth{cmd}{text}

# Assuming noone tries to get clever with figuring out the allocation of 
# numbers, these become simple DefRegister's
DefPrimitive('\newcount{Token}', sub { DefRegister($_[1]->toString,Number(0)); });
DefPrimitive('\newdimen{Token}', sub { DefRegister($_[1]->toString,Dimension(0)); });
DefPrimitive('\newskip{Token}',  sub { DefRegister($_[1]->toString,Glue(0)); });
DefPrimitive('\newmuskip{Token}',sub { DefRegister($_[1]->toString,MuGlue(0)); });
#DefPrimitive('\newbox{Token}',  sub { DefRegister($_[1]->toString,LaTeXML::Box->new()); });
DefPrimitive('\newtoks{Token}',  sub { DefRegister($_[1]->toString,Tokens()); });

#======================================================================
# C.13.2 Space
#======================================================================
DefPrimitive('\hspace OptionalMatch:* {}',undef);
DefPrimitive('\vspace OptionalMatch:* {}',undef);
# \addvspace{len}
# \hfill, \vfill

#======================================================================
# C.13.3 Boxes
#======================================================================
DefConstructor('\mbox{}',
	       "<ltx:text>#1</ltx:text>", mode=>'text');
DefConstructor('\makebox[Dimension][]{}',
	       "<ltx:text ?#1(width='#1') ?#2(pos='#2')>#3</ltx:text>",
	       mode=>'text');
DefConstructor('\fbox{}',
	       "<ltx:text framed='rectangle'>#1</ltx:text>", mode=>'text');
DefConstructor('\framebox[Dimension][]{}',
	       "<ltx:text ?#1(width='#1') ?#2(pos='#2') framed='rectangle'>#3</ltx:text>",
	       mode=>'text');
DefPrimitive('\newsavebox{Token}',sub { AssignValue('box'.$_[1]->toString, LaTeXML::List->new()); });
DefPrimitive('\sbox{Token}{}',sub {
   AssignValue('box'.$_[1]->toString, Digest($_[2])); return;});
DefPrimitive('\savebox{Token}[][]{}',sub {
   AssignValue('box'.$_[1]->toString, Digest($_[4])); return;});
DefEnvironment('{lrbox}{Token}','',
  afterDigest=>sub{ 
    my($stomach,$whatsit)=@_;
    AssignValue('box'.$whatsit->getArg(1)->toString, $whatsit->getProperty('body')); });
DefPrimitive('\usebox{Token}', sub { LookupValue('box'.$_[1]->toString);});

DefConstructor('\parbox[][Dimension]{}',
	       "<ltx:minipage ?#2(width='#2') ?#1(pos='#1') justified='yes'>#3</ltx:minipage>",
	       mode=>'text');
DefEnvironment('{minipage}[]{Dimension}',
	       "<ltx:minipage ?#2(width='#2') ?#1(pos='#1') justified='yes'>#body</ltx:minipage>",
	       mode=>'text');
DefConstructor('\rule[Dimension]{Dimension}{Dimension}', 
	       "<ltx:rule ?#1(raise='#1') width='#2' height='#3'/>");
DefConstructor('\raisebox{Dimension}[Dimension][Dimension]{}',
	       "<ltx:text raise='#1'>#4</ltx:text>");

#**********************************************************************
# C.14 Pictures and Color
#**********************************************************************
#======================================================================
# C.14.1 The picture environment
#======================================================================

#----------------------------------------------------------------------

sub ResolveReader {
  my ($itemtype) = @_;
  if(ref $itemtype eq 'CODE'){ $itemtype; }
  else {
    $itemtype = $itemtype->toString if ref $itemtype;
    LaTeXML::Parameters::checkReaderFunction('Read'.$itemtype); }}

sub ReadPair {
  my($gullet,$itemtype, $xarg, $yarg)=@_;
  my $itemreader;
  if(!$itemtype){ $itemreader=\&ReadFloat; }
  else { $itemreader = ResolveReader($itemtype); }
  if(!$itemreader){ Error("Cannot find reader for Pair items from $itemtype"); }
  $gullet->skipSpaces;
  if($gullet->ifNext(T_OTHER('('))){
    $gullet->readToken;  $gullet->skipSpaces;
    my $x = &$itemreader($gullet,$xarg);
    $gullet->skipSpaces; $gullet->readUntil(T_OTHER(',')); $gullet->skipSpaces;
    my $y = &$itemreader($gullet,$yarg);
    $gullet->skipSpaces; $gullet->readUntil(T_OTHER(')')); $gullet->skipSpaces;
    Pair($x,$y); }}

sub ReadFloat { $_[0]->skipSpaces; $_[0]->readFloat; }

sub ptValue { $_[0]?$_[0]->ptValue:undef; }

# This eases conversion of a Pair to 2 attributes.
sub PairAttr {
  my($pair,$xattr,$yattr)=@_;
  ($pair ? { $xattr=>ptValue($pair->getX), $yattr=>ptValue($pair->getY) } : {}); }

sub SimplePairAttr {
  my($pair,$xattr,$yattr)=@_;
  ($pair ? { $xattr=>$pair->getX, $yattr=>$pair->getY } : {}); }

#----------------------------------------------------------------------
# Picture parameters.
DefRegister('\unitlength', Dimension('1pt'));
DefPrimitive('\thinlines', sub { AssignValue('\@wholewidth',Dimension('0.4pt')); });
DefPrimitive('\thicklines', sub { AssignValue('\@wholewidth',Dimension('0.8pt')); });
DefRegister('\@wholewidth'=>Dimension('0.4pt'));
DefMacro('\linethickness{}', '\@wholewidth #1\relax');

DefPrimitive('\arrowlength{Dimension}', sub { AssignValue('\arrowlength',$_[1]); });

#----------------------------------------------------------------------
# Picture transformation support
sub slopeToPicCoord {
  my ($slope,$xlength) = @_;
  my($mx,$my)=($slope->getX,$slope->getY);
  my $s = $mx->sign();
  $xlength = picScale($xlength);
  Pair($xlength->multiply($s),
       $xlength->multiply(($s==0)?$my->sign():
			  $my->valueOf/$mx->absolute->valueOf)); }

sub picScale {
  ($_[0] ? $_[0]->multiply(LookupValue('\unitlength')): undef); }

sub picProperties {
  my (%props) = @_;
  if(($props{stroke}||'black') ne 'none'){
    $props{thick}=ptValue(LookupValue('\@wholewidth')); }
  if (my $arrowlength=LookupValue('\arrowlength')){
    $props{arrowlength}=ptValue($arrowlength); }
  %props; }

#----------------------------------------------------------------------
# the code
sub before_picture {
  Let(T_CS('\line'),     T_CS('\pic@line'));
  Let(T_CS('\vector'),   T_CS('\pic@vector'));
  Let(T_CS('\circle'),   T_CS('\pic@circle'));
  Let(T_CS('\oval'),     T_CS('\pic@oval'));
  Let(T_CS('\qbezier'),  T_CS('\pic@qbezier'));
  Let(T_CS('\makebox'),  T_CS('\pic@makebox'));
  Let(T_CS('\framebox'), T_CS('\pic@framebox'));
  Let(T_CS('\dashbox'),  T_CS('\pic@dashbox'));
  Let(T_CS('\frame'),    T_CS('\pic@frame'));
}

sub after_picture {}

# NOTE: Untex should prefix a setting of unitlength!!!
DefEnvironment('{picture} Pair OptionalPair',
	       "<ltx:picture %&SimplePairAttr(#size,width,height) fill='black' stroke='black'>"
	       . "#body"
	       ."</ltx:picture>",
	       beforeDigest=>\&before_picture,
	       properties=>sub { picProperties(size=>picScale($_[1])); },
	       afterDigest=>\&after_picture);

DefConstructor('\put Pair {}',
	       "<ltx:g transform='#pos'>#2</ltx:g>",
	       properties=>sub { pos=>'translate('.ptValue(picScale($_[1])).')'; });

DefConstructor('\pic@line Pair {Float}',
	       "<ltx:line points='#points' stroke-width='#thick'/>",
	       alias=>'\line',
	       properties=>sub { picProperties(points=>'0,0 '.slopeToPicCoord($_[1],$_[2])->ptValue()); });

DefConstructor('\pic@vector Pair {Float}',
	       "<ltx:line points='#points' stroke-width='#thick' terminators='->'"
	       . " arrowlength='#arrowlength'/>",
	       alias=>'\vector',
	       properties=>sub { picProperties(points=>'0,0 '.slopeToPicCoord($_[1],$_[2])->ptValue()); });

DefConstructor('\pic@circle OptionalMatch:* {Float}',
	       "<ltx:circle x='0' y='0' r='&ptValue(#radius)' fill='#fill' stroke='#stroke'"
	       .  " stroke-width='#thick'/>",
	       alias=>'\circle',
	       properties=>sub {
		 my ($stomach,$filled,$dia) = @_;
		 $dia=picScale($dia);
		 $dia=$dia->add(LookupValue('\@wholewidth')) unless $filled;
		 picProperties(radius=>$dia->multiply(0.5),
			       ($filled ? 'stroke' : 'fill')=>'none'); });

DefConstructor('\pic@oval [Float] Pair []',
	       "<ltx:rect %&PairAttr(#pos,x,y) %&PairAttr(#size,width,height) rx='&ptValue(#radius)'"
	       . "  fill='none' part='#3' stroke-width='#thick'/>",
	       alias=>'\oval',
	       properties=>sub{
		 my ($stomach,$r,$size,$part) = @_;
		 $size = picScale($size);
		 my $halfsize = $size->multiply(0.5);
		 my $pos = Pair($halfsize->getX->negate,$halfsize->getY->negate);
		 $r = ($r ? picScale($r) : Dimension('40pt'));
		 $r=$r->smaller($halfsize->getX->absolute);
		 $r=$r->smaller($halfsize->getY->absolute);
		 picProperties(size=>$size, pos=>$pos, radius=>$r); });

DefConstructor('\pic@qbezier [Number] Pair Pair Pair',
               "<ltx:bezier ?#1(displayedpoints='#1') points='&ptValue(#pt)' stroke-width='#thick' />",
	       alias=>'\qbezier',
	       properties=>sub {
		 picProperties(pt=>PairList(picScale($_[2]),picScale($_[3]),picScale($_[4]))); });

DefConstructor('\pic@makebox Pair []{}',
	       "<ltx:g %&PairAttr(#size,width,height) pos='#2'>#3</ltx:g>",
	       alias=>'\makebox',
	       properties=>sub { picProperties(size=>picScale($_[1])); });

DefConstructor('\pic@framebox Pair []{}',
	       "<ltx:rect x='0' y='0' %&PairAttr(#size,width,height) stroke-width='#thick' fill='none'/>"
	       . "<ltx:g %&PairAttr(#size,width,height) pos='#2'> #3 </ltx:g>",
	       alias=>'\framebox',
	       properties=>sub { picProperties(size=>picScale($_[1])); });

DefConstructor('\pic@dashbox {Float} Pair [] {}',
	       "<ltx:rect x='0' y='0' %&PairAttr(#size,width,height)"
	       . " stroke-width='#thick' stroke-dasharray='&ptValue(#dash)' fill='none'/>".
	       "<ltx:g %&PairAttr(#size,width,height) pos='#3'> #4 </ltx:g>",
	       alias=>'\dashbox',
	       properties=>sub { picProperties(dash=>picScale($_[1]),size=>picScale($_[2])); });

DefConstructor('\pic@frame{}',
	       "<ltx:g framed='yes' stroke-width='#thick'>#1</ltx:g>",
	       alias=>'\frame',
	       properties=>sub { picProperties(); });

our %alignments = (l=>'left',c=>'center',r=>'right');
DefConstructor('\shortstack[]{}',
	       "<ltx:vbox align='#align'><ltx:text>#2</ltx:text></ltx:vbox>",
	       bounded=>1,
	       beforeDigest=>sub{ DefConstructor("\\\\ OptionalMatch:* []",
						 "</ltx:text><ltx:text>", alias=>"\\\\\n"); },
	       properties=>{ align=>sub { ($_[1] ? $alignments{ToString($_[0])} : undef); }},
	       mode=>'text');

DefMacro('\multiput Pair Pair {}{}',  sub {
	   my($gullet,$pos,$d,$n,$body)=@_;
	   my($x,$y,$dx,$dy,$n)=map($_->toString, ($pos->getX,$pos->getY,$d->getX,$d->getY,$n));
	   my @exp=();
	   for(my $i=0; $i<$n; $i++){
	     push(@exp,T_CS('\put'),T_OTHER('('),Explode($x),T_OTHER(','),Explode($y),T_OTHER(')'),
		  T_BEGIN,$body->unlist,T_END);
	     $x += $dx; $y+=$dy; }
	   @exp; });

sub add_picture_TeX {
  my($document,$node,$thing)=@_;
  if($thing && !$thing->getProperty('_added_tex')){
    local $LaTeXML::PICTURE_SCALE = Dimension('1pt')->valueOf;
    my $tex = ToString(Tokens($thing->revert));
    $node->setAttribute(tex=>$tex); }
  $thing->setProperty('_added_tex',1); }

Tag('ltx:picture',   afterOpen=>\&add_picture_TeX);

Tag('ltx:g', afterClose=> sub {
      my ($document,$node) = @_;
      $node->parentNode->removeChild($node) unless $node->hasChildNodes; });

# \savebox -- already defined differntly in C.13 above ? 

#**********************************************************************
# C.15 Font Selection
#**********************************************************************
#======================================================================
# C.15.1 Changing the Type Style
#======================================================================
# Text styles.

# What about \f@family, etc....?
# These are not allowed in math.
DefConstructor('\mdseries', '',  forbidMath=>1, font=>{series=>'medium'});
DefConstructor('\bfseries', '',  forbidMath=>1, font=>{series=>'bold'});

DefConstructor('\rmfamily', '',  forbidMath=>1, font=>{family=>'serif'});
DefConstructor('\sffamily', '',  forbidMath=>1, font=>{family=>'sansserif'});
DefConstructor('\ttfamily', '',  forbidMath=>1, font=>{family=>'typewriter'});

DefConstructor('\upshape',  '', forbidMath=>1, font=>{shape=>'upright'});
DefConstructor('\itshape',  '', forbidMath=>1, font=>{shape=>'italic'});
DefConstructor('\slshape',  '', forbidMath=>1, font=>{shape=>'slanted'});
DefConstructor('\scshape',  '', forbidMath=>1, font=>{shape=>'smallcaps'});

DefConstructor('\normalfont', '', font=>{family=>'serif', series=>'medium', shape=>'upright'});

DefConstructor('\verbatim@font', '', font=>{family=>'typewriter', series=>'medium', shape=>'upright'});

# If these series or shapes appear in math, they revert it to roman, medium, upright (?)
DefConstructor('\textmd{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{series=>'medium'});
DefConstructor('\textbf{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{series=>'bold'});
DefConstructor('\textrm{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{family=>'serif'});
DefConstructor('\textsf{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{family=>'sansserif'});
DefConstructor('\texttt{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{family=>'typewriter'});

DefConstructor('\textup{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'upright'});
DefConstructor('\textit{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'italic'});
DefConstructor('\textsl{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'slanted'});
DefConstructor('\textsc{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'smallcaps'});

DefConstructor('\textnormal{}', '#1',
	       bounded=>1, font=>{family=>'serif',series=>'medium',shape=>'upright'});

DefPrimitive('\mathversion{}',sub {
  my($stomach,$version)=@_;
  $version = $version->toString;
  if($version eq 'bold'     ){ 
    AssignValue(mathfont=>LookupValue('mathfont')->merge(forcebold=>1), 'local'); }
  elsif($version eq 'normal'){ 
    AssignValue(mathfont=>LookupValue('mathfont')->merge(forcebold=>0), 'local'); }
  else { Fatal("Unknown math verison \"$version\""); }});

#======================================================================
# C.15.2 Changing the Type Size
#======================================================================
# Handled in Primitive.pm

#======================================================================
# C.15.3 Special Symbol
#======================================================================
# \symbol{num} ????

# These in LaTeX, but not in the book...
DefConstructor('\textdollar',"\$");
DefConstructor('\textemdash',"\x{2014}"); # EM DASH
DefConstructor('\textendash',"\x{2013}"); # EN DASH
DefConstructor('\textexclamdown',"\x{00A1}"); # INVERTED EXCLAMATION MARK
DefConstructor('\textquestiondown',"\x{00BF}");	# INVERTED QUESTION MARK
DefConstructor('\textquotedblleft',"\x{201C}"); # LEFT DOUBLE QUOTATION MARK
DefConstructor('\textquotedblright',"\x{201D}"); # RIGHT DOUBLE QUOTATION MARK
DefConstructor('\textquoteleft',"\x{2018}");     # LEFT SINGLE QUOTATION MARK
DefConstructor('\textquoteright',"\x{2019}");    # RIGHT SINGLE QUOTATION MARK
DefConstructor('\textsterling',"\x{OOA3}");	 # POUND SIGN
DefConstructor('\textasteriskcentered',"*");
DefConstructor('\textbackslash',"\x{005C}"); # REVERSE SOLIDUS
DefConstructor('\textbar',"|");
DefConstructor('\textbraceleft',"{");
DefConstructor('\textbraceright',"}");
DefConstructor('\textbullet',"\x{2022}");    # BULLET
DefConstructor('\textdaggerdbl',"\x{2020}"); # DOUBLE DAGGER
DefConstructor('\textdagger',"\x{2021}");    # DAGGER
DefConstructor('\textparagraph',"\x{00B6}"); # PILCROW SIGN
DefConstructor('\textperiodcentered',"\x{22C5}"); # DOT OPERATOR
DefConstructor('\textsection',"\x{00A7}");	      # SECTION SIGN
DefConstructor('\textcircled{}',"<ltx:text framed='circle'>#1</ltx:text>");
DefConstructor('\textless',"<");
DefConstructor('\textgreater',">");
DefConstructor('\textcopyright',"\x{00A9}"); # COPYRIGHT SIGN
DefConstructor('\textasciicircum',"^");
DefConstructor('\textasciitilde',"~");
DefConstructor('\textcompwordmark',""); # ???
DefConstructor('\textunderscore',"_");
DefConstructor('\textvisiblespace',"\x{2420}"); # SYMBOL FOR SPACE;  Not really the right symbol!
DefConstructor('\textellipsis',"\x{2026}"); # HORIZONTAL ELLIPSIS
DefConstructor('\textregistered',"\x{00AE}"); # REGISTERED SIGN
DefConstructor('\texttrademark',"\x{2122}");  # TRADE MARK SIGN
DefConstructor('\textsuperscript{}',"<ltx:text raise='0.5em'>#1</ltx:text>");
DefConstructor('\textordfeminine',"\x{00AA}"); # FEMININE ORDINAL INDICATOR
DefConstructor('\textordmasculine',"\x{00BA}"); # MASCULINE ORDINAL INDICATOR


#**********************************************************************
# Other stuff
#**********************************************************************
# Some stuff that got missed in the appendices ?

DefMacro('\@namedef{}','\expandafter\def\csname #1\endcsname');
DefMacro('\@nameuse{}','\csname #1\endcsname');

DefMacro('\@spaces','\space\space\space\space');
Let('\@sptoken',T_SPACE);
#======================================================================
# Internals used in Packages
DefMacro('\NeedsTeXFormat{}','');
DefMacro('\ProvidesClass{}[]','');
DefMacro('\ProvidesPackage{}[]','');
DefMacro('\DeclareOption{}{}', sub {
  my($gullet,$option,$code)=@_;
  InstallDefinition(
       LaTeXML::Expandable->new(T_CS('\ds@'.$option->toString),undef,
		   Expand(Tokens($gullet->neutralizeTokens($code->unlist)))));
  (); });

DefMacro('\ExecuteOptions{}', sub{
  my($gullet,$options)=@_;
  map(T_CS('\ds@'.$_),split(',',$options->toString)); });
DefMacro('\ProcessOptions','');
DefMacro('\@ehc',"I can't help");

sub make_message {
  my($cs,@args)=@_;
  join("\n",map(Expand($_)->toString,@args)); }

DefMacro('\@onlypreamble{}',''); # Don't bother enforcing this.

DefMacro('\GenericError{}{}{}{}', sub{ Fatal(make_message(@_)); });
DefMacro('\GenericWarning{}{}',   sub{ Warn(make_message(@_)); });
DefMacro('\GenericInfo{}{}{}{}',  sub{ print STDERR "Info: ".make_message(@_)."\n"; });

DefMacro('\PackageError{}{}{}',
  ' \GenericError{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      Package #1 Error: #2%
   }{%
      See the #1 package documentation for explanation.%
   }{#3}');
DefMacro('\PackageWarning{}{}',
   '\GenericWarning{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      Package #1 Warning: #2%
   }');
DefMacro('\PackageWarningNoLine{}{}',
  ' \PackageWarning{#1}{#2\@gobble}');
DefMacro('\PackageInfo{}{}',
  '\GenericInfo{%
      (#1) \@spaces\@spaces\@spaces
   }{%
      Package #1 Info: #2%
   }');
DefMacro('\ClassError{}{}{}',
  '\GenericError{%
      (#1) \space\@spaces\@spaces\@spaces
   }{%
      Class #1 Error: #2%
   }{%
      See the #1 class documentation for explanation.%
   }{#3}');
DefMacro('\ClassWarning{}{}',
  '\GenericWarning{%
      (#1) \space\@spaces\@spaces\@spaces
   }{%
      Class #1 Warning: #2%
   }');
DefMacro('\ClassWarningNoLine{}{}',
  '\ClassWarning{#1}{#2\@gobble}');
DefMacro('\ClassInfo{}{}',
  '\GenericInfo{%
      (#1) \space\space\@spaces\@spaces
   }{%
      Class #1 Info: #2%
   }');
DefMacro('\@latex@error{}{}',
  '\GenericError{%
      \space\space\space\@spaces\@spaces\@spaces
   }{%
      LaTeX Error: #1%
   }{%
      See the LaTeX manual or LaTeX Companion for explanation.%
   }{#2}');
DefMacro('\@latex@warning{}',
  '\GenericWarning{%
      \space\space\space\@spaces\@spaces\@spaces
   }{%
      LaTeX Warning: #1%
   }');
DefMacro('\@latex@warning@no@line{}',
  '\@latex@warning{#1\@gobble}');
DefMacro('\@latex@info{}',
   '\GenericInfo{%
      \@spaces\@spaces\@spaces
   }{%
      LaTeX Info: #1%
   }');
DefMacro('\@latex@info@no@line{}',
  '\@latex@info{#1\@gobble}');

#======================================================================

#======================================================================
# Some control structure from latex.ltx
# (amazing that it actually works!)
# How much of this control struture will I need?
RawTeX(<<'EOTeX');
\def\@nnil{\@nil}
\def\@empty{}
\def\@fornoop#1\@@#2#3{}
\long\def\@for#1:=#2\do#3{%
  \expandafter\def\expandafter\@fortmp\expandafter{#2}%
  \ifx\@fortmp\@empty \else
    \expandafter\@forloop#2,\@nil,\@nil\@@#1{#3}\fi}
\long\def\@forloop#1,#2,#3\@@#4#5{\def#4{#1}\ifx #4\@nnil \else
       #5\def#4{#2}\ifx #4\@nnil \else#5\@iforloop #3\@@#4{#5}\fi\fi}
\long\def\@iforloop#1,#2\@@#3#4{\def#3{#1}\ifx #3\@nnil
       \expandafter\@fornoop \else
      #4\relax\expandafter\@iforloop\fi#2\@@#3{#4}}

EOTeX

#======================================================================
DefMacro('\check@mathfonts','');
DefMacro('\fontsize{}{}','');
DefMacro('\math@fontsfalse','');
DefMacro('\math@fontstrue','');
DefMacro('\selectfont','');

#======================================================================
# Various symbols, accents, etc from Chapter 3 defined in Primitives.pm

#**********************************************************************
# Semi-Undocumented stuff
#**********************************************************************
DefMacro('\@ifnextchar Token {}{}', sub {
  my($gullet,$token,$if,$else)=@_;
  my $next = $gullet->readNonSpace;
  # NOTE: Not actually substituting, but collapsing ## pairs!!!!
  ( LaTeXML::Expandable::substituteTokens($token->equals($next) ? $if : $else),$next); });

DefMacro('\@ifundefined{}{}{}',sub {
  my($gullet,$name,$if,$else)=@_;
  my $cs = T_CS('\\'.ToString($name));
  (LookupMeaning($cs) ne $cs ? $if->unlist : $else->unlist); });

DefMacro('\IfFileExists{}{}{}', sub{
  my($gullet,$file,$if,$else)=@_;
  (pathname_find($file->toString,paths=>LookupValue('SEARCHPATHS')) ? $if->unlist : $else->unlist); });

DefMacro('\InputIfFileExists{}{}', sub{
  my($gullet,$file,$if)=@_;
  if(pathname_find($file->toString,paths=>LookupValue('SEARCHPATHS'))){
    $gullet->input($file);
    $if->unlist; }
  else { (); }});

#======================================================================
# Hair
DefPrimitive('\makeatletter',sub { AssignCatcode('@'=>CC_LETTER,'local'); });
DefPrimitive('\makeatother', sub { AssignCatcode('@'=>CC_OTHER, 'local'); });

#**********************************************************************
#**********************************************************************
# Sundry (is this ams ?)
DefConstructor('\textprime',"\x{00B4}"); # ACUTE ACCENT

#**********************************************************************
1;
