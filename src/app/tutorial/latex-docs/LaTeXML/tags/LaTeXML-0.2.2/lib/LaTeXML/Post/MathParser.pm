# /=====================================================================\ #
# |  LaTeXML::Post::MathParser                                          | #
# | Postprocessor to parse math                                         | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
# ================================================================================
# LaTeXML::Post::MathParser  Math Parser for LaTeXML using Parse::RecDescent.
# Parse the intermediate representation generated by the TeX processor.
# ================================================================================
package LaTeXML::Post::MathParser;
use strict;
use Parse::RecDescent;
use LaTeXML::Util::LibXML;
use LaTeXML::Post::MathDictionary;
use Exporter;
use LaTeXML::Post;
our @ISA = (qw(Exporter LaTeXML::Post::Processor));

our @EXPORT_OK = (qw(&Lookup &New &Apply &recApply &Annotate &InvisibleTimes
		     &NewFormulae &NewFormula &NewCollection  &ApplyDelimited &NewScripts
		     &LeftRec
		     &Arg &Problem &MaybeFunction
		     &isMatchingClose &Fence));
our %EXPORT_TAGS = (constructors => [qw(&Lookup &New &Apply &recApply &Annotate &InvisibleTimes
					&NewFormulae &NewFormula &NewCollection  &ApplyDelimited &NewScripts
					&LeftRec
					&Arg &Problem &MaybeFunction 
					&isMatchingClose &Fence)]);
our $nsURI = "http://dlmf.nist.gov/LaTeXML";
our $nsXML = "http://www.w3.org/XML/1998/namespace";
# ================================================================================
sub new {
  my($class,%options)=@_;

  # Hackery to recompile the grammar.
  my ($dir) = grep( -f "$_/LaTeXML/Post/MathGrammar", @INC);
  $dir .= "/LaTeXML/Post";
  if ((!-f "$dir/MathGrammar.pm") || (-M "$dir/MathGrammar" < -M "$dir/MathGrammar.pm")){
    system("cd $dir; perl -MParse::RecDescent - MathGrammar LaTeXML::Post::MathGrammar"); }

  require LaTeXML::Post::MathGrammar;
  my $internalparser = LaTeXML::Post::MathGrammar->new();
  die("Math Parser grammar failed") unless $internalparser;

  my $self = bless {internalparser => $internalparser},$class;
  $self->init(%options);
  $self; }

sub process {
  my($self,$doc,%options)=@_;
  $self->clear;			# Not reentrant!
  $self->cacheIDs($doc);

  my $dict = LaTeXML::Post::MathDictionary::getDocumentDictionary($doc,$self->getSource);
  my @math =  $self->findMathNodes($doc);
  $self->Progress("Parsing ".scalar(@math)." formulae");
  foreach my $math (@math){
    $self->parse($math,$doc,$dict); }
  $self->showSummary;
  $doc; }

# ================================================================================
sub clear {
  my($self)=@_;
  $$self{passed}={XMath=>0,XMArg=>0,XMWrap=>0};
  $$self{failed}={XMath=>0,XMArg=>0,XMWrap=>0};
  $$self{unknowns}={};
  $$self{maybe_functions}={};
}
sub showSummary {
  my($self)=@_;
  $self->Progress("Math parsing succeeded:"
		  .join('',map( "\n   $_: ".$$self{passed}{$_}."/".($$self{passed}{$_}+$$self{failed}{$_}),
				keys %{$$self{passed}})));
  if(my @unk = keys %{$$self{unknowns}}){
    $self->Warn("Symbols assumed as simple identifiers (with # of occurences):\n   "
		.join(', ',map("'$_' ($$self{unknowns}{$_})",sort @unk))); }
  if(my @funcs = keys %{$$self{maybe_functions}}){
    $self->Warn("Possibly used as functions? (with # suspicious usages/# of occurrences):\n  "
		.join(', ',map("'$_' ($$self{maybe_functions}{$_}/$$self{unknowns}{$_} times)",
			       sort @funcs))); }
}

sub note_unknown {
  my($self,$name)=@_;
  $$self{unknowns}{$name}++ if $LaTeXML::Post::MathParser::STRICT; }

# ================================================================================
# Some more XML utilities, but math specific (?)

sub getTokenName {		# Get the Token's name, or fall back to content
  my($node)=@_;
  $node->getAttribute('name') || $node->textContent;}

sub getTokenContent {		# Get the Token's content, or fall back to name.
  my($node)=@_;
  $node->textContent || $node->getAttribute('name'); }

sub node_TeX {
  my($node)=@_;
  $node->getAttribute('tex') || $node->textContent;}

sub node_string {
  my($node)=@_;
  my($string,$x);
#  if(defined ($x=$node->getAttribute('tex'))){ $string=$x; }
#  elsif(defined ($x=$node->getAttribute('name'))) { $string=$x; }
#  elsif(($node->nodeName eq 'XMTok')&& (defined ($x=$node->textContent))){ $string=$x; }
#  else{ $string=$node->nodeName; }
  $string = text_form($node);
  ($node->getAttribute('role')||'Unknown').'['.$string.']'; }

sub node_location {
  my($node)=@_;
  my $n = $node;
  while($n && (ref $n ne 'XML::LibXML::Document')
	&& !$n->getAttribute('refnum') && !$n->getAttribute('label')){
    $n = $n->parentNode; }
  if($n && (ref $n ne 'XML::LibXML::Document')){
    my($r,$l)=($n->getAttribute('refnum'),$n->getAttribute('label'));
    ($r && $l ? "$r ($l)" : $r || $l); }
  else {
    'Unknown'; }}

# ================================================================================
# Customizable?

sub findMathNodes {
  my($self,$doc)=@_;
  $doc->getElementsByTagNameNS($self->getNamespace,'XMath'); }

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Parser
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sub parse {
  my($self,$xnode,$doc,$dict)=@_;
  local $LaTeXML::Post::MathParser::STRICT=1;

  my $nodedict = $dict->getNodeDictionary($xnode);
  if(my $result = $self->parse_rec($xnode,'Anything,',$doc,$nodedict)){
    # Add text representation to the containing Math element.
    $xnode->parentNode->setAttribute('text',text_form($result)); }
}

# Recursively parse a node with some internal structure
# by first parsing any structured children, then it's content.
sub parse_rec {
  my($self,$node,$rule,$doc,$dict)=@_;
  $self->parse_children($node,$doc,$dict);
  my $tag  = $node->nodeName;
  if(my $requested_rule = $node->getAttribute('rule')){
    $rule = $requested_rule; }
  if(my $result= $self->parse_internal($node,$doc,$dict,$rule)){
    $$self{passed}{$tag}++;
   if($tag eq 'XMath'){	# Replace content of XMath
      clear_node($node);
      map($node->removeChild($_),element_nodes($node));
      append_nodes($node,$result); }
    else {			# Replace node for XMArg, XMWrap; preserve some attributes
      if(my $role = $node->getAttribute('role')){
	$result->setAttribute('role',$role); }
      if(my $id = $node->getAttributeNS($nsXML,'id')){
	$result->setAttributeNS($nsXML,id=>$id);
	$self->updateID($result,$id); }
      $node->parentNode->replaceChild($result,$node); }
    $result; }
  else {
    $$self{failed}{$tag}++;
    undef; }}

# Depth first parsing of XMArg nodes.
sub parse_children {
  my($self,$node,$doc,$dict)=@_;
  foreach my $child (element_nodes($node)){
    my $tag = $child->nodeName;
    if($tag eq 'XMArg'){
      $self->parse_rec($child,'Anything',$doc,$dict); }
    elsif($tag eq 'XMWrap'){
      local $LaTeXML::Post::MathParser::STRICT=0;
      $self->parse_rec($child,'Anything',$doc,$dict); }
    elsif(($tag eq 'XMApp')||($tag eq 'XMDual')){
      $self->parse_children($child,$doc,$dict); }
}}

# ================================================================================

sub parse_internal {
  my($self,$mathnode,$doc,$dict,$rule)=@_;
  #  Remove Hints!
  my @nodes = element_nodes($mathnode);
  @nodes = grep( $_->nodeName ne 'XMHint', @nodes);

  # Extract trailing punctuation, if rule allows it.
  my ($punct, $result,$textified);
  if($rule =~ s/,$//){
    my ($x,$r) = ($nodes[$#nodes]);
    $punct =($x && ($x->nodeName eq 'XMTok') 
	     && (  $r = $x->getAttribute('role')
		   || (defined($x = getTokenName($x)) && ($r = $dict->getRole($x))))
	     && ($r eq 'PUNCT')
	     ? pop(@nodes) : ''); }
  my $nnodes = scalar(@nodes);
  
  if($nnodes == 0){	     # Probably the wrong thing to do, but ...
    $result = New('Empty'); }
  elsif($nnodes == 1){		# One node? What's to parse?
    $result = $nodes[0]; }
  else {
    # Generate a textual token for each node; The parser operates on this encoded string.
    local $LaTeXML::Post::MathParser::LEXEMES = {};
    my $i = 0;
    $textified='';
    foreach my $node (@nodes){
      my $tag = $node->nodeName;
      my $rnode = $node;
      if($tag eq 'XMRef'){
	$rnode = $self->realizeXMNode($doc,$node);
	$tag = $rnode->nodeName; }
      my $name = getTokenName($rnode);
      $name = 'Unknown' unless defined $name;
      my $role = $rnode->getAttribute('role');
#      if(!defined $role){
#	$role = $dict->getRole($name);
#	# Hack: record UNKNOWN on Wrapped tokens, so we know they're not known!
#	$role = 'UNKNOWN' if (!defined $role) &&($tag eq 'XMTok') && !$LaTeXML::Post::MathParser::STRICT;
#	$node->setAttribute('role',$role) if defined $role; }
      $role = ($tag eq 'XMTok' ? 'UNKNOWN' : 'ATOM') unless defined $role;
      my $lexeme      = $role.":".$name.":".++$i;
      $lexeme =~ s/\s//g;
      if(($role eq 'UNKNOWN') && $LaTeXML::Post::MathParser::STRICT){
	$self->note_unknown($name);
	if($name eq 'Unknown'){
	  $self->Warn("MathParser: What is this: \"".$node->toString."\"?"); }}
      $$LaTeXML::Post::MathParser::LEXEMES{$lexeme} = $node;
      $textified .= ' '.$lexeme; }
    #print STDERR "MathParse Node:\"".join(' ',map(node_string($_),@nodes))."\"\n => \"$textified\"\n";
    # Finally, apply the parser to the textified sequence.
    local $LaTeXML::Post::MathParser::PARSER = $self;
    $result = $$self{internalparser}->$rule(\$textified); }

  # Failure: report on what/where
  # NOTE: Should do script hack??
  if((! defined $result) || $textified){
    if($LaTeXML::Post::MathParser::STRICT){
      $textified =~ s/^\s*//;
      my @rest=split(/ /,$textified);
      my $pos = scalar(@nodes) - scalar(@rest);
      my $parsed  = join(' ',map(node_string($_),@nodes[0..$pos-1]));
      my $toparse = join(' ',map(node_string($_),@nodes[$pos..$#nodes]));
      my $lexeme = node_location($nodes[$pos] || $nodes[$pos-1] || $mathnode);
      $self->Warn("MathParser failed to match rule $rule for ".$mathnode->nodeName." at pos. $pos in $lexeme at\n"
		  . ($parsed ? $parsed."\n".(' ' x (length($parsed)-2)) : '')."> ".$toparse);
    }
    undef; }
  # Success!
  else {
    $result->setAttribute('punctuation',getTokenContent($punct)) if $punct;
    $result; }}

# ================================================================================
# Conversion to a less ambiguous, mostly-prefix form.

sub text_form {
  my($node)=@_;
#  $self->textrec($node,0); }
# Hmm, Something Weird is broken!!!!
# With <, I get "unterminated entity reference" !?!?!?
#  my $text= $self->textrec($node,0); 
  my $text= textrec($node,undef); 
  $text =~ s/</LessThan/g;
  $text; }


our %PREFIX_ALIAS=(Superscript=>'^',Subscript=>'_', "\x{2062}"=>'*');
# Put infix, along with `binding power'
our %IS_INFIX = (METARELOP=>1, 
		 RELOP=>2, ARROW=>2,
		 ADDOP=>10, MULOP=>100, 
		 SUPERSCRIPT=>1000, SUBSCRIPT=>1000);

sub textrec {
  my($node, $outer_bp,$outer_name)=@_;
  my $tag = $node->nodeName;
  $outer_bp = 0 unless defined $outer_bp;
  $outer_name = '' unless defined $outer_name;
  if($tag eq 'XMApp') {
    my($op,@args) = element_nodes($node);
    my $name = (($op->nodeName eq 'XMTok') && getTokenName($op)) || 'unknown';
    my $role  =  $op->getAttribute('role') || 'Unknown';
    my ($bp,$string);
    if($bp = $IS_INFIX{$role}){
      # Format as infix.
      $string = (scalar(@args) == 1 # unless a single arg; then prefix.
		  ? textrec($op) .' '.textrec($args[0],$bp,$name)
		  : join(' '. textrec($op) .' ',map(textrec($_,$bp,$name), @args))); }
    elsif($role eq 'POSTFIX'){
      $bp = 10000;
      $string = textrec($args[0],$bp,$name).textrec($op); }
    elsif($name eq 'MultiRelation'){
      $bp = 2;
      $string = join(' ',map(textrec($_,$bp,$name),@args)); }
    elsif($name eq 'Fenced'){
      $bp = -1;			# to force parentheses
      $string = join(', ',map(textrec($_),@args)); }
    else {
      $bp = 500;
      $string = textrec($op,10000,$name) .'@(' . join(', ',map(textrec($_),@args)). ')'; }
    (($bp < $outer_bp)||(($bp==$outer_bp)&&($name ne $outer_name)) ? '('.$string.')' : $string); }
  elsif($tag eq 'XMDual'){
    my($content,$presentation)=element_nodes($node);
    textrec($content,$outer_bp,$outer_name); } # Just send out the semantic form.
  elsif($tag eq 'XMTok'){
    my $name = getTokenName($node);
    return 'Unknown' unless defined $name;
    $PREFIX_ALIAS{$name} || $name; }
  elsif($tag eq 'XMWrap'){
    # ??
    join('@',map(textrec($_), element_nodes($node))); }
  else {
    my $string = ($tag eq 'text' ? $node->textContent :     $node->getAttribute('tex') || '?');
      "[$string]"; }}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Constructors used in grammar
# All the tree construction in the grammar should come through these operations.
# We have to be _extremely_ careful about cloning nodes when using addXML::LibXML!!!
# If we add one node to another, it is _silently_ removed from any parent it may have had!
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# ================================================================================
# Low-level accessors
sub Lookup {
  my($lexeme)=@_;
  $$LaTeXML::Post::MathParser::LEXEMES{$lexeme}; }

# Make a new Token node with given name, content, and attributes.
sub New {
  my($name,$content,%attribs)=@_;
  Annotate(new_node($nsURI,'XMTok',$content),($name? (name=>$name):()),%attribs); }

# Get n-th arg of an XMApp.
sub Arg {
  my($node,$n)=@_;
  my @args = element_nodes($node);
  $args[$n]; }			# will get cloned if/when needed.

# Add more attributes to a node.
sub Annotate {
  my($node,%attribs)=@_;
  foreach my $attr (sort keys %attribs){
    my $value = $attribs{$attr};
    $value = getTokenName($value) if ref $value;
    $node->setAttribute($attr,$value) if defined $value; }
  $node; }

# ================================================================================
# Mid-level constructors

# Apply $op to the list of arguments
sub Apply {
  my($op,@args)=@_;
  new_node($nsURI,'XMApp', [$op,@args]); }

# Apply $op to a `delimited' list of arguments of the form
#     open, expr (punct expr)* close
# after extracting the opening and closing delimiters, and the separating punctuation
sub ApplyDelimited {
  my($op,@stuff)=@_;
  my $open =shift(@stuff);
  my $close=pop(@stuff);
  $open  = getTokenContent($open)  if ref $open;
  $close = getTokenContent($close) if ref $close;
  my ($seps,@args)=extract_separators(@stuff);
  Apply(Annotate($op, argopen=>$open, argclose=>$close, separators=>$seps),@args); }

# Given a sequence of operators, form the nested application op(op(...(arg)))
sub recApply {
  my(@ops)=@_;
  (scalar(@ops)>1 ? Apply(shift(@ops),recApply(@ops)) : $ops[0]); }

# Given  alternating expressions & separators (punctuation,...)
# extract the separators as a concatenated string,
# returning (separators, args...)
sub extract_separators {
  my(@stuff)=@_;
  my ($punct,@args);
  if(@stuff){
    push(@args,shift(@stuff));
    while(@stuff){
      $punct .= shift(@stuff)->textContent;
      push(@args,shift(@stuff)); }}
  ($punct,@args); }

# ================================================================================
# Some special cases 

sub InvisibleTimes {
  New('',"\x{2062}", role=>'MULOP'); }


# OK, what about \left. or \right. !!?!?!!?!?!?
# Make customizable?
# Should I just check left@right against enclose1 ?
our %balanced = ( '(' => ')', '['=>']', '{'=>'}', 
		  '|'=>'|', 'Parallel'=>'Parallel',
		  'lfloor'=>'rfloor','lceil'=>'rceil','langle'=>'rangle');
our %enclose1 = ( '(@)'=>'Fenced', '[@]'=>'Fenced', '{@}'=>'Set',
		  '|@|'=>'Abs', '||@||'=>'Abs', 'Parallel@Parallel'=>'Abs',
		  'LeftFloor@RightFloor'=>'Floor', 'LeftCeiling@RightCeiling'=>'Ceiling' );
our %enclose2 = ( '(@)'=>'OpenInterval', '[@]'=>'ClosedInterval',
		  '(@]'=>'OpenLeftInterval', '[@)'=>'OpenRightInterval',
		  '{@}'=>'Set',
		  # Nah, too weird.
		  #'{@}'=>'SchwarzianDerivative',
		  #'LeftAngle@RightAngle'=>'Distribution' 
		);
our %encloseN = ( '(@)'=>'Vector','{@}'=>'Set',);

sub isMatchingClose {
  my($open,$close)=@_;
  my $oname = getTokenName($open);
  my $cname = getTokenName($close);
  return 1 if $oname eq '.';
  my $expect = $balanced{$oname};
  warn "Unknown OPEN delimiter \"$oname\"" unless defined $expect;
  ($expect eq $cname) || ($cname eq '.'); }

# Given a delimited sequence: open expr (punct expr)* close
# Convert it into the appropriate thing, depending on the specific open & close used.
# If the open/close are `simple' delimiters and there is only one expr,
# simply add open/close attributes.
sub Fence {
  my(@stuff)=@_;
  # Peak at delimiters to guess what kind of construct this is.
  my ($open,$close) = ($stuff[0],$stuff[$#stuff]);
  my $openname  = (ref $open  ? getTokenName($open) : $open);
  my $closename = (ref $close ? getTokenName($close): $close);
  my $key = $openname.'@'.$closename;
  my $n = int(scalar(@stuff)-2+1)/2;
  my $op = (($n==1) && $enclose1{$key}) || (($n==2) && $enclose2{$key}) || (($n > 2) && $encloseN{$key})
    || 'Collection';
  if(($n==1) && ($op eq 'Fenced')){ # Simple case.
    my $node = $stuff[1];
    $node->setAttribute(open=>getTokenContent($open)) if $open && ($openname ne '.');
    $node->setAttribute(close=>getTokenContent($close)) if $close && ($closename ne '.');
    $node; }
  else {
    ApplyDelimited(New($op,undef,role=>'FENCED'),@stuff); }}

# NOTE: It might be best to separate the multiple Formulae into separate XMath's???
# but only at the top level!
sub NewFormulae {
  my(@stuff)=@_;
  if(scalar(@stuff)==1){ $stuff[0]; }
  else { 
    my ($seps,@formula)=extract_separators(@stuff);
    Apply(New('Formulae',undef, separators=>$seps),@formula);}}

# A Formula is an alternation of expr (relationalop expr)*
# It presumably would be equivalent to (expr1 relop1 expr2) AND (expr2 relop2 expr3) ...
# But, I haven't figured out the ideal prefix form that can easily be converted to presentation.
sub NewFormula {
  my(@args)=@_;
  my $n = scalar(@args);
  if   ($n == 1){ $args[0];}
  elsif($n == 3){ Apply($args[1],$args[0],$args[2]); }
  else          { Apply(New('MultiRelation'),@args); }}

sub NewCollection {
  my(@stuff)=@_;
  if(@stuff == 1){ $stuff[0]; }
  else {
    my ($seps,@items)=extract_separators(@stuff);
    Apply(New('Collection',undef, separators=>$seps, role=>'FENCED'),@items);}}

# Given alternation of expr (addop expr)*, compose the tree (left recursive),
# flattenning portions that have the same operator
# ie. a + b + c - c  =>  (- (+ a b c) d)
sub LeftRec {
  my($arg1,@more)=@_;
  if(@more){
    my $op = shift(@more);
    my $opname = getTokenName($op);
    my @args = ($arg1,shift(@more));
    while(@more && ($opname eq getTokenName($more[0]))){
      shift(@more);
      push(@args,shift(@more)); }
    LeftRec(Apply($op,@args),@more); }
  else {
    $arg1; }}

# ================================================================================
# Construct an appropriate application of sub/superscripts
# $postsub & $postsuper are POSTSUBSCRIPT and POSTSUPERSCRIPT objects
# (ie. an XMApp with the script as 1st arg).
sub NewScripts {
  my($base,$postsub,$postsup,$presub,$presup)=@_;
  if($presub||$presup){
    # NOTE: Stupid arrangement for sideset!!! Fix this!!
    Apply(New('sideset'),
	  ($presub  ? Arg($presub,0)  : New('Empty')),
	  ($presup  ? Arg($presup,0)  : New('Empty')),
	  ($postsub ? Arg($postsub,0) : New('Empty')),
	  ($postsup ? Arg($postsup,0) : New('Empty')),
	  $base); }
  elsif($postsub && $postsup){
    Apply(New('SubSuperscript'),$base,Arg($postsub,0),Arg($postsup,0)); }
  elsif($postsub){
    Apply(New('Subscript',undef, role=>'SUBSCRIPT'),$base,Arg($postsub,0)); }
  elsif($postsup){
    Apply(New('Superscript',undef, role=>'SUPERSCRIPT'),$base,Arg($postsup,0)); }}

# ================================================================================
sub Problem { warn("MATH Problem? ",@_); }

# Note that an UNKNOWN token may have been used as a function.
# For simplicity in the grammar, we accept a token that has sub|super scripts applied.
sub MaybeFunction {
  my($token)=@_;
  my $self = $LaTeXML::Post::MathParser::PARSER;
  while($token->nodeName eq 'XMApp'){
    $token = Arg($token,1); }
  my $name = getTokenName($token);
  $token->setAttribute('possibleFunction','yes');
  $$self{maybe_functions}{$name}++ 
    unless !$LaTeXML::Post::MathParser::STRICT or   $$self{suspicious_tokens}{$token};
  $$self{suspicious_tokens}{$token}=1; }

# ================================================================================
1;
