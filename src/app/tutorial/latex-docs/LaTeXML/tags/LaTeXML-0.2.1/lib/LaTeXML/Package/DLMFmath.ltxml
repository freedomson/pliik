# -*- CPERL -*-
# /=====================================================================\ #
# |  DLMFmath                                                           | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

# Currently only a random collection of things I need for DLMF chapters.
# Eventually, go through the doc and implement it all.
#**********************************************************************
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;

#**********************************************************************
# Load special functions & other required packages.
RequirePackage('amsmath');

$STOMACH->addSearchPath("$ENV{HOME}/dlmf/styles/DLMFtex/");

RequirePackage('DLMFfcns');

#**********************************************************************
# General Math Constructs

DefMath('\Real',      "\x{211D}", role=>'ID'); # DOUBLE-STRUCK CAPITAL R
DefMath('\Complex',   "\x{2102}", role=>'ID'); # DOUBLE-STRUCK CAPITAL C
DefMath('\NatNumber', "\x{2115}", role=>'ID'); # DOUBLE-STRUCK CAPITAL N
DefMath('\Integer',   "\x{2124}", role=>'ID'); # DOUBLE-STRUCK CAPITAL Z
DefMath('\Rational',  "\x{211A}", role=>'ID'); # DOUBLE-STRUCK CAPITAL Q
DefMath('\Polynomial',"\x{2119}", role=>'ID'); # DOUBLE-STRUCK CAPITAL P

# Redefined here, since Frank doesn't like the Fraktur.
DefMath('\Re',       "Re", role=>'FUNCTION');
DefMath('\Im',       "Im", role=>'FUNCTION');

DefMath('\realpart{}', "\x{211C}");	# BLACK-LETTER CAPITAL R
DefMath('\imagpart{}', "\x{2111}");	# BLACK-LETTER CAPITAL I

DefMath('\iunit',"\x{2148}", role=>'ID', name=>'iunit'); # DOUBLE-STRUCK ITALIC SMALL I
DefMacro('\opminus',   "(-1)");

# \cfrac covered in amsmath.
# \midvert, \midVert ??

DefMath('\floor{}','\left\lfloor#1\right\rfloor');
DefMath('\ceiling{}','\left\lceil#1\right\rceil');

#**********************************************************************
# Numbers
#   \Sci{mantisa}{exponent}
my %SUPDIGITS = (0=>"\x{2070}",1=>"\x{00b9}",2=>"\x{00b2}",3=>"\x{00b3}",4=>"\x{2074}",
		 5=>"\x{2075}",6=>"\x{2076}",7=>"\x{2077}",8=>"\x{2078}",9=>"\x{2079}",
		'+'=>"\x{207a}", '-'=>"\x{207b}");
sub convert_sci {
  my($mantissa,$exponent)=@_;
  $mantissa = $mantissa->toString;
  $exponent = $exponent->toString;
  ($exponent ? join('',$mantissa,"\x{00D7}10",map($SUPDIGITS{$_}||'?',split('',$exponent))) : $mantissa); }

DefConstructor('\Sci{}{}',sub {
  my($whatsit,$mantissa,$exponent)=@_;
  my $string = convert_sci($mantissa,$exponent);
  ($whatsit->isMath 
   ? $INTESTINE->insertMathToken($string,font=>$whatsit->getFont)
   : $INTESTINE->openText($string,$whatsit->getFont)); });

# In table variant: uses r@{}l for column spec.
#   \TSci{mantisa}{exponent}
#DefConstructor('\TSci{}{}',sub {
#  my($whatsit,$mantissa,$exponent)=@_;
#  my $savenode = $INTESTINE->floatToAttribute('colspan');
#  $INTESTINE->getNode->setAttribute(colspan=>2);
#  $INTESTINE->setNode($savenode);
#  my $string = convert_sci($mantissa,$exponent);
#  ($whatsit->isMath ? $INTESTINE->openText($string,$whatsit->getFont)
#   : $INTESTINE->insertMathToken($string,font=>$whatsit->getFont)); });

# Worry about alignment later...
DefMacro('\TSci{}{}','\multicolumn{2}{c}{\Sci{#1}{#2}}');

DefConstructor('\thinhline',"<hline size='thin'/>"); # ?

#**********************************************************************
# Calculus
# Handled as general constructors since empty numerator is effectively a differential
# operator, instead of a derivative.
DefConstructor('\deriv[]{}{}',  
	       "<XMApp ?#2()(role='DIFFOP')>"
	       . "<XMTok name='deriv' style='#style'/>?#2(<XMArg>#2</XMArg>)(<XMTok name='Empty'/>)"
	       . "<XMArg>#3</XMArg>?#1(<XMArg>#1</XMArg>)</XMApp>",
	       beforeDigest=>\&beforeFrac, afterDigest =>\&afterFrac);
DefConstructor('\pderiv[]{}{}',
	       "<XMApp ?#2()(role='DIFFOP')>"
	       . "<XMTok name='pderiv' style='#style'/>?#2(<XMArg>#2</XMArg>)(<XMTok name='Empty'/>)"
	       . "<XMArg>#3</XMArg>?#1(<XMArg>#1</XMArg>)</XMApp>",
	       beforeDigest=>\&beforeFrac, afterDigest =>\&afterFrac);
DefConstructor('\ideriv[]{}{}',
	       "<XMApp ?#2()(role='DIFFOP')>"
	       . "<XMTok name='deriv' style='inline'/>?#2(<XMArg>#2</XMArg>)(<XMTok name='Empty'/>)"
	       . "<XMArg>#3</XMArg>?#1(<XMArg>#1</XMArg>)</XMApp>");
DefConstructor('\ipderiv[]{}{}',
	       "<XMApp ?#2()(role='DIFFOP')>"
	       . "<XMTok name='pderiv' style='inline'/>?#2(<XMArg>#2</XMArg>)(<XMTok name='Empty'/>)"
	       . "<XMArg>#3</XMArg>?#1(<XMArg>#1</XMArg>)</XMApp>");
DefConstructor('\diff[]{}',
	       "<XMApp><XMTok name='diff'/><XMArg>#2</XMArg>?#1(<XMArg>#1</XMArg>)</XMApp>");
DefConstructor('\pdiff[]{}',
	       "<XMApp><XMTok name='pdiff'/><XMArg>#2</XMArg>?#1(<XMArg>#1</XMArg>)</XMApp>");

#**********************************************************************
DefMath('\pvint',  "\x{2A0D}", name=>'PrincipalValueIntegral', role=>'INTOP'); # FINITE PART INTEGRAL
DefMath('\Residue', "res",     name=>"Residue", role=>'LIMITOP');

#**********************************************************************
# Types

# Missing something critical here....
DefMacro('\Vector{}','\boldsymbol{#1}');
DefMacro('\Matrix{}','\boldsymbol{#1}');

DefMath('\divergence', "div",  role=>'DIFFOP');
DefMath('\curl',       "curl", role=>'DIFFOP');
DefMath('\gradient',   "grad", role=>'DIFFOP');
DefMath('\transpose{}','#1^{\mathrm{T}}');

#**********************************************************************
# Combinatorics
DefMath('\multinomial{}{}', '', name=>'multinomial');
DefMath('\pochhammer{}{}',  '', name=>'pochhammer');
DefMath('\binomial{}{}',    '', name=>'binomial');

#**********************************************************************
# Constants
DefMath('\EulerConstant',"\x{03B3}", role=>'ID'); # GREEK SMALL LETTER GAMMA

#**********************************************************************
# Special Functions
DefPrimitive('\specFunObsolete{}{}',sub {
  my($defn,$old,$new)=@_;
  DefMacro("\\".$old->toString,"\\".$new->toString); });

sub count_tokens {
  my($token)=@_;
  my $n=0;
  while($GULLET->readMatch($token)){ $n++; }
  $n; }

#**********************************************************************

DefPrimitive('\defSpecFun{}[][]{}{}', sub {
  my($self,$name,$nparam,$optparam,$formatter,$nargs)=@_;
  $name=$name->toString;
  my $cs = '\\'.$name;
  $nargs  = $nargs->toString;

  # Define with DefMath to create presentation & content cs's
  DefMath($cs . convertLaTeXArgs($nparam,$optparam), $formatter, role=>'FUNCTION', omcd=>'dlmf');
  # Then, redefine top-level macro to check for powers, args, etc.
  DefExpandable($cs.convertLaTeXArgs($nparam,$optparam),  sub { expand_specfun($cs,@_); });

  # Read any argument formats & generate args macros
  my @argfmts=();
  while(my $af = $GULLET->readOptional){
    push(@argfmts,$af); }
  push(@argfmts, Tokenize("\\!\\left(".join(',',map("#$_",1..$nargs))."\\right)"))
    unless @argfmts;
  for(my $i=0; $i <= $#argfmts; $i++){
    DefMacro(join('',$cs,'@args',('@' x ($i+1)),('{}' x $nargs)),$argfmts[$i]->toString); }

  $GULLET->skipSpaces();
  return; });

DefConstructor('\sf@apply{}{}', "<XMApp>#1#2</XMApp>",
  untex => sub {
    my($fcn,$args) = $_[0]->getArgs;
    $fcn->untex . "@" . join('',map("{".$_->untex."}", $args->unlist)); });

DefExpandable('\@PRIMES{}',sub { ((T_CS('\prime')) x $_[1]->toString); });
DefMath('\diffop{}{}','{{#1}^{\@PRIMES{#2}}}');
DefMath('\power{}{}',"{#1^{#2}}");

sub expand_specfun {
  my($cs,$self,@params)=@_;
  my($cparams,$pparams)=dualize_arglist(@params);
  my $ccall = T_CS($cs.'@content')->invocation(@$cparams);
  my $pcall = T_CS($cs.'@presentation')->invocation(@$pparams);

  # Check for following primes and superscripts, and wrap the function appropriately.
  while(my $op = $GULLET->readMatch(T_OTHER("'"),T_SUPER)){ # Hmm, ' is active only in math?
    if($op->equals(T_SUPER)){
      # NOTE: Before I go assuming that ^{x} is a power, consider analyzing for things like ^{(n)} !!!
      my($cpower,$ppower) = dualize_arglist($GULLET->readArg); # Should do xmref here too!!!
      $ccall = T_CS('\power@content')->invocation($ccall,@$cpower);
      $pcall = T_CS('\power@presentation')->invocation($pcall,@$ppower); }
    else{
      my $n = 1+count_tokens($op);
      $ccall = T_CS('\diffop@content')->invocation($ccall,T_OTHER($n));
      $pcall = T_CS('\diffop@presentation')->invocation($pcall,T_OTHER($n));}}

  # Check for function arguments
  if(my $variant = count_tokens(T_OTHER('@'))){
    my $argsmacro = T_CS($cs.'@args'.('@' x $variant))->getDefinition;
    my($cargs,$pargs)=dualize_arglist($argsmacro->readArguments);
    T_CS('\DUAL')->invocation(T_OTHER('ATOM'),
			      T_CS('\sf@apply')->invocation($ccall,Tokens(map((@$_),@$cargs))),
			      Tokens(@$pcall,T_CS('\@APPLYFUNCTION'),
				     $argsmacro->invocation(@$pargs)->unlist)
			     )->unlist; }
  else {
    T_CS('\DUAL')->invocation(T_OTHER('FUNCTION'), $ccall, $pcall)->unlist}; }

#**********************************************************************
1;

