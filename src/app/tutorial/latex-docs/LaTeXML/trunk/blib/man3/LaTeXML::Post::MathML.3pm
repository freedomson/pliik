.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LaTeXML::Post::MathML 3pm"
.TH LaTeXML::Post::MathML 3pm "2012-07-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
\&\f(CW\*(C`LaTeXML::Post::MathML\*(C'\fR, \f(CW\*(C`LaTeXML::Post::MathML::Presentation\*(C'\fR, \f(CW\*(C`LaTeXML::Post::MathML::Content\*(C'\fR
\&\- Post-Processing modules for converting math to MathML.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`LaTeXML::Post::MathML\*(C'\fR is the abstract base class for the MathML Postprocessor;
\&\f(CW\*(C`LaTeXML::Post::MathML::Presentation\*(C'\fR and \f(CW\*(C`LaTeXML::Post::MathML::Content\*(C'\fR
convert XMath to either Presentation or Content MathML, or with that format
as the principle branch for Parallel markup.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The conversion is carried out primarly by a tree walk of the \f(CW\*(C`XMath\*(C'\fR expression;
appropriate handlers are selected and called depending on the operators and forms encountered.
Handlers can be defined on applications of operators, or on tokens;
when a token is applied, it's application handler takes precedence over it's token handler
.ie n .SS """DefMathML($key,$presentation,$content);"""
.el .SS "\f(CWDefMathML($key,$presentation,$content);\fP"
.IX Subsection "DefMathML($key,$presentation,$content);"
Defines presentation and content handlers for \f(CW$key\fR.
\&\f(CW$key\fR is of the form \f(CW\*(C`TYPE:ROLE:MEANING\*(C'\fR, where
.PP
.Vb 3
\&  TYPE    : is one either C<Token> or C<Apply> (or C<Hint> ?)
\&  ROLE    : is a grammatical role (on XMath tokens)
\&  MEANING : is the meaning attribute (on XMath tokens)
.Ve
.PP
Any of these can be \f(CW\*(C`?\*(C'\fR to match any role or meaning;
matches of both are preferred, then match of meaning
or role, or neither.
.PP
The subroutine handlers for presentation and content are given
by \f(CW$presentation\fR and \f(CW$content\fR, respectively.
Either can be \f(CW\*(C`undef\*(C'\fR, in which case some other matching
handler will be invoked.
.PP
For \f(CW\*(C`Token\*(C'\fR handlers, the arguments passed are the token node;
for \f(CW\*(C`Apply\*(C'\fR handler, the arguments passed are the operator node
and any arguments.
.PP
However, it looks like some \f(CW\*(C`TOKEN\*(C'\fR handlers are being defined
to take \f(CW\*(C`$content,%attributes\*(C'\fR being the string content of the token,
and the token's attributes!
.SS "Presentation Conversion Utilties"
.IX Subsection "Presentation Conversion Utilties"
.ie n .IP """$mmlpost\->pmml_top($node,$style);""" 4
.el .IP "\f(CW$mmlpost\->pmml_top($node,$style);\fR" 4
.IX Item "$mmlpost->pmml_top($node,$style);"
This is the top-level converter applied to an \f(CW\*(C`XMath\*(C'\fR node.
It establishes a local context for font, style, size, etc.
It generally does the bulk of the work for a PresentationMathML's \f(CW\*(C`translateNode\*(C'\fR,
although the latter wraps the actual \f(CW\*(C`m:math\*(C'\fR element around it.
(\f(CW\*(C`style\*(C'\fR is display or text).
.ie n .IP """pmml($node)"", ""pmml_smaller($node)"", ""pmml_scriptsizsize($node)""" 4
.el .IP "\f(CWpmml($node)\fR, \f(CWpmml_smaller($node)\fR, \f(CWpmml_scriptsizsize($node)\fR" 4
.IX Item "pmml($node), pmml_smaller($node), pmml_scriptsizsize($node)"
Converts the \f(CW\*(C`XMath\*(C'\fR \f(CW$node\fR to Presentation MathML.
The latter two are used when the context calls for smaller (eg. fraction parts)
or scriptsize (eg sub or superscript) size or style, so that the size encoded
within \f(CW$node\fR will be properly accounted for.
.ie n .IP """pmml_mi($node,%attributes)"", ""pmml_mn($node,%attributes)"", ""pmml_mo($node,%attributes)""" 4
.el .IP "\f(CWpmml_mi($node,%attributes)\fR, \f(CWpmml_mn($node,%attributes)\fR, \f(CWpmml_mo($node,%attributes)\fR" 4
.IX Item "pmml_mi($node,%attributes), pmml_mn($node,%attributes), pmml_mo($node,%attributes)"
These are \f(CW\*(C`Token\*(C'\fR handlers, to create \f(CW\*(C`m:mi\*(C'\fR, \f(CW\*(C`m:mn\*(C'\fR and \f(CW\*(C`m:mo\*(C'\fR elements,
respectively.  When called as a handler, they will be supplied only with an \f(CW\*(C`XMath\*(C'\fR
node (typically an \f(CW\*(C`XMTok\*(C'\fR). For convenient reuse, these functions may also be called
on a 'virtual' token: with \f(CW$node\fR being a string (that would have been the text
content of the \f(CW\*(C`XMTok\*(C'\fR), and the \f(CW%attributes\fR that would have been the token's attributes.
.ie n .IP """pmml_infix($op,@args)"", ""pmml_script($op,@args)"", ""pmml_bigop($op,@args)""" 4
.el .IP "\f(CWpmml_infix($op,@args)\fR, \f(CWpmml_script($op,@args)\fR, \f(CWpmml_bigop($op,@args)\fR" 4
.IX Item "pmml_infix($op,@args), pmml_script($op,@args), pmml_bigop($op,@args)"
These are \f(CW\*(C`Apply\*(C'\fR handlers, for handling general infix, sub or superscript,
or bigop (eg. summations) constructs.  They are called with the operator
token, followed by the arguments; all are \f(CW\*(C`XMath\*(C'\fR elements.
.ie n .IP """pmml_row(@items)""" 4
.el .IP "\f(CWpmml_row(@items)\fR" 4
.IX Item "pmml_row(@items)"
This wraps an \f(CW\*(C`m:mrow\*(C'\fR around the already converted \f(CW@items\fR if neeed;
That is, if there is only a single item it is returned without the \f(CW\*(C`m:mrow\*(C'\fR.
.ie n .IP """pmml_unrow($pmml)""" 4
.el .IP "\f(CWpmml_unrow($pmml)\fR" 4
.IX Item "pmml_unrow($pmml)"
This perverse utility takes something that has already been converted
to Presentation MathML.  If the argument is an \f(CW\*(C`m:mrow\*(C'\fR, it returns a list of the
mathml elements within that row, otherwise it returns a list containing
the single element \f(CW$pmml\fR.
.ie n .IP """pmml_parenthesize($item,$open,$close)""" 4
.el .IP "\f(CWpmml_parenthesize($item,$open,$close)\fR" 4
.IX Item "pmml_parenthesize($item,$open,$close)"
This utility parenthesizes the (already converted MathML) \f(CW$item\fR with the string delimiters
\&\f(CW$open\fR and \f(CW$close\fR.  Currently, it converts to an \f(CW\*(C`m:mfenced\*(C'\fR
(But could convert to an \f(CW\*(C`m:mrow\*(C'\fR).
.ie n .IP """pmml_punctuate($separators,@items) """ 4
.el .IP "\f(CWpmml_punctuate($separators,@items) \fR" 4
.IX Item "pmml_punctuate($separators,@items) "
This utility creates an \f(CW\*(C`m:mrow\*(C'\fR by interjecting the punctuation
between suceessive items in the list of already converted \f(CW@items\fR.
If there are more than one character in \f(CW$separators\fR the first
is used between the first pair, the next between the next pair;
if the separators is exhausted, the last is repeated between remaining pairs.
\&\f(CW$separators\fR defaults to (repeated) comma.
.SS "Content Conversion Utilties"
.IX Subsection "Content Conversion Utilties"
.ie n .IP """$mmlpost\-""cmml_top($node); >" 4
.el .IP "\f(CW$mmlpost\-\fRcmml_top($node); >" 4
.IX Item "$mmlpost-cmml_top($node); >"
This is the top-level converter applied to an \f(CW\*(C`XMath\*(C'\fR node.
It establishes a local context for font, style, size, etc (were it needed).
It generally does the bulk of the work for a ContentMathML's \f(CW\*(C`translateNode\*(C'\fR,
although the latter wraps the actual \f(CW\*(C`m:math\*(C'\fR element around it.
.ie n .IP """cmml($node)""" 4
.el .IP "\f(CWcmml($node)\fR" 4
.IX Item "cmml($node)"
Converts the \f(CW\*(C`XMath\*(C'\fR \f(CW$node\fR to Content MathML.
.ie n .IP """cmml_ci($token)""" 4
.el .IP "\f(CWcmml_ci($token)\fR" 4
.IX Item "cmml_ci($token)"
Converts the \f(CW\*(C`XMath\*(C'\fR token to an \f(CW\*(C`m:ci\*(C'\fR.
(This may evolve to generate a \f(CW\*(C`m:csymbol\*(C'\fR, under appropriate circumstances)
.ie n .IP """cmml_decoratedSymbol($item)""" 4
.el .IP "\f(CWcmml_decoratedSymbol($item)\fR" 4
.IX Item "cmml_decoratedSymbol($item)"
Similar to \f(CW\*(C`cmml_ci\*(C'\fR, but used when an operator is itself, apparently, an application.
This converts \f(CW$item\fR to Presentation MathML to use for the content of the \f(CW\*(C`m:ci\*(C'\fR.
.ie n .IP """cmml_not($arg)""" 4
.el .IP "\f(CWcmml_not($arg)\fR" 4
.IX Item "cmml_not($arg)"
Construct the not of the argument \f(CW$arg\fR.
.ie n .IP """cmml_synth_not($op,@args)""" 4
.el .IP "\f(CWcmml_synth_not($op,@args)\fR" 4
.IX Item "cmml_synth_not($op,@args)"
Synthesize an operator by applying \f(CW\*(C`m:not\*(C'\fR to another operator (\f(CW$op\fR) applied to its \f(CW@args\fR
(\f(CW\*(C`XMath\*(C'\fR elements that will be converted to Content MathML).
This is useful to define a handler for, eg., c<not\-approximately\-equals> in terms
of c<m:approx>.
.ie n .IP """cmml_synth_complement($op,@args)""" 4
.el .IP "\f(CWcmml_synth_complement($op,@args)\fR" 4
.IX Item "cmml_synth_complement($op,@args)"
Synthesize an operator by applying a complementary operator (\f(CW$op\fR) to the reverse of its \f(CW@args\fR
(\f(CW\*(C`XMath\*(C'\fR elements that will be converted to Content MathML).
This is useful to define a handler for, eg. \f(CW\*(C`superset\-of\-or\-equals\*(C'\fR using \f(CW\*(C`m:subset\*(C'\fR.
.ie n .IP """cmml_or_compose($operators,@args)""" 4
.el .IP "\f(CWcmml_or_compose($operators,@args)\fR" 4
.IX Item "cmml_or_compose($operators,@args)"
Synthesize an operator that stands for the \f(CW\*(C`or\*(C'\fR of several other operators
(eg. c<less\-than\-or\-similar\-to\-or\-approximately\-equals>) by composing it
of the \f(CW\*(C`m:or\*(C'\fR of applying each of \f(CW\*(C`m:less\*(C'\fR and \f(CW\*(C`m:approx\*(C'\fR to the arguments.
The first operator is applied to the converted arguments, while the rest
are applied to \f(CW\*(C`m:share\*(C'\fR elements referring to the previous ones.
.ie n .IP """cmml_share($node)""" 4
.el .IP "\f(CWcmml_share($node)\fR" 4
.IX Item "cmml_share($node)"
Converts the \f(CW\*(C`XMath\*(C'\fR \f(CW$node\fR to Content MathML, after assuring that it has an id,
so that it can be shared.
.ie n .IP """cmml_shared($node)""" 4
.el .IP "\f(CWcmml_shared($node)\fR" 4
.IX Item "cmml_shared($node)"
Generates a \f(CW\*(C`m:share\*(C'\fR element referting to \f(CW$node\fR, which should have 
an id (such as after calling \f(CW\*(C`cmml_share\*(C'\fR).
.SH "Math Processors, Generally."
.IX Header "Math Processors, Generally."
We should probably formalize the idea of a Math Processor as an
abstract class, but let this description provide a starting overview.
A MathProcessor follows the \s-1API\s0 of \f(CW\*(C`LaTeXML::Post\*(C'\fR processors, by
handling \f(CW\*(C`process\*(C'\fR, which invokes \f(CW\*(C`processNode\*(C'\fR on all \f(CW\*(C`Math\*(C'\fR nodes;
That latter inserts the result of either \f(CW\*(C`translateNode\*(C'\fR or
\&\f(CW\*(C`translateParallel\*(C'\fR, applied to the \f(CW\*(C`XMath\*(C'\fR representation, into the \f(CW\*(C`Math\*(C'\fR node.
.PP
Parallel translation is done whenever additional MathProcessors have
been specified, via the \f(CW\*(C`setParallel\*(C'\fR method; these are simply other
MathProcessors following the same \s-1API\s0.
