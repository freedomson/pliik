.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LaTeXML::MathParser 3pm"
.TH LaTeXML::MathParser 3pm "2012-07-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
\&\f(CW\*(C`LaTeXML::MathParser\*(C'\fR \- parses mathematics content
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`LaTeXML::MathParser\*(C'\fR parses the mathematical content of a document.
It uses Parse::RecDescent and a grammar \f(CW\*(C`MathGrammar\*(C'\fR.
.SS "Math Representation"
.IX Subsection "Math Representation"
Needs description.
.SS "Possibile Customizations"
.IX Subsection "Possibile Customizations"
Needs description.
.SS "Convenience functions"
.IX Subsection "Convenience functions"
The following functions are exported for convenience in writing the
grammar productions.
.ie n .IP """$node = New($name,$content,%attributes);""" 4
.el .IP "\f(CW$node = New($name,$content,%attributes);\fR" 4
.IX Item "$node = New($name,$content,%attributes);"
Creates a new \f(CW\*(C`XMTok\*(C'\fR node with given \f(CW$name\fR (a string or undef),
and \f(CW$content\fR (a string or undef) (but at least one of name or content should be provided),
and attributes.
.ie n .IP """$node = Arg($node,$n);""" 4
.el .IP "\f(CW$node = Arg($node,$n);\fR" 4
.IX Item "$node = Arg($node,$n);"
Returns the \f(CW$n\fR\-th argument of an \f(CW\*(C`XMApp\*(C'\fR node;
0 is the operator node.
.ie n .IP """Annotate($node,%attributes);""" 4
.el .IP "\f(CWAnnotate($node,%attributes);\fR" 4
.IX Item "Annotate($node,%attributes);"
Add attributes to \f(CW$node\fR.
.ie n .IP """$node = Apply($op,@args);""" 4
.el .IP "\f(CW$node = Apply($op,@args);\fR" 4
.IX Item "$node = Apply($op,@args);"
Create a new \f(CW\*(C`XMApp\*(C'\fR node representing the application of the node
\&\f(CW$op\fR to the nodes \f(CW@args\fR.
.ie n .IP """$node = ApplyDelimited($op,@stuff);""" 4
.el .IP "\f(CW$node = ApplyDelimited($op,@stuff);\fR" 4
.IX Item "$node = ApplyDelimited($op,@stuff);"
Create a new \f(CW\*(C`XMApp\*(C'\fR node representing the application of the node
\&\f(CW$op\fR to the arguments found in \f(CW@stuff\fR.  \f(CW@stuff\fR are 
delimited arguments in the sense that the leading and trailing nodes
should represent open and close delimiters and the arguments are
seperated by punctuation nodes.  The text of these delimiters and
punctuation are used to annotate the operator node with
\&\f(CW\*(C`argopen\*(C'\fR, \f(CW\*(C`argclose\*(C'\fR and \f(CW\*(C`separator\*(C'\fR attributes.
.ie n .IP """$node = recApply(@ops,$arg);""" 4
.el .IP "\f(CW$node = recApply(@ops,$arg);\fR" 4
.IX Item "$node = recApply(@ops,$arg);"
Given a sequence of operators and an argument, forms the nested
application \f(CW\*(C`op(op(...(arg)))\*(C'\fR>.
.ie n .IP """$node = InvisibleTimes;""" 4
.el .IP "\f(CW$node = InvisibleTimes;\fR" 4
.IX Item "$node = InvisibleTimes;"
Creates an invisible times operator.
.ie n .IP """$boole = isMatchingClose($open,$close);""" 4
.el .IP "\f(CW$boole = isMatchingClose($open,$close);\fR" 4
.IX Item "$boole = isMatchingClose($open,$close);"
Checks whether \f(CW$open\fR and \f(CW$close\fR form a `normal' pair of
delimiters, or if either is \*(L".\*(R".
.ie n .IP """$node = Fence(@stuff);""" 4
.el .IP "\f(CW$node = Fence(@stuff);\fR" 4
.IX Item "$node = Fence(@stuff);"
Given a delimited sequence of nodes, starting and ending with open/close delimiters,
and with intermediate nodes separated by punctuation or such, attempt to guess what
type of thing is represented such as a set, absolute value, interval, and so on.
If nothing specific is recognized, creates the application of \f(CW\*(C`FENCED\*(C'\fR to the arguments.
.Sp
This would be a good candidate for customization!
.ie n .IP """$node = NewFormulae(@stuff);""" 4
.el .IP "\f(CW$node = NewFormulae(@stuff);\fR" 4
.IX Item "$node = NewFormulae(@stuff);"
Given a set of formulas, construct a \f(CW\*(C`Formulae\*(C'\fR application, if there are more than one,
else just return the first.
.ie n .IP """$node = NewList(@stuff);""" 4
.el .IP "\f(CW$node = NewList(@stuff);\fR" 4
.IX Item "$node = NewList(@stuff);"
Given a set of expressions, construct a \f(CW\*(C`list\*(C'\fR application, if there are more than one,
else just return the first.
.ie n .IP """$node = LeftRec($arg1,@more);""" 4
.el .IP "\f(CW$node = LeftRec($arg1,@more);\fR" 4
.IX Item "$node = LeftRec($arg1,@more);"
Given an expr followed by repeated (op expr), compose the left recursive tree.
For example \f(CW\*(C`a + b + c \- d\*(C'\fR would give \f(CW\*(C`(\- (+ a b c) d)\*(C'\fR>
.ie n .IP """Problem($text);""" 4
.el .IP "\f(CWProblem($text);\fR" 4
.IX Item "Problem($text);"
Warn of a potential math parsing problem.
.ie n .IP """MaybeFunction($token);""" 4
.el .IP "\f(CWMaybeFunction($token);\fR" 4
.IX Item "MaybeFunction($token);"
Note the possible use of \f(CW$token\fR as a function, which may cause incorrect parsing.
This is used to generate warning messages.
.SH "AUTHOR"
.IX Header "AUTHOR"
Bruce Miller <bruce.miller@nist.gov>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Public domain software, produced as part of work done by the
United States Government & not subject to copyright in the \s-1US\s0.
