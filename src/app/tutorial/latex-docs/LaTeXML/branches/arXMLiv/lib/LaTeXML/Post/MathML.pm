# /=====================================================================\ #
# |  LaTeXML::Post::MathML                                              | #
# | MathML generator for LaTeXML                                        | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

# ================================================================================
# LaTeXML::MathML  Math Formatter for LaTeXML's Parsed Math.
#   Cooperate with the parsed math structure generated by LaTeXML::Math and
# convert into presentation MathML.
# ================================================================================
# Some clarity to work out:
#  We're trying to convert either parsed or unparsed math (sometimes intertwined).
# How clearly do these have to be separated?
# at least, sub/superscripts do not attach to anything meaningful.
# ================================================================================

package LaTeXML::Post::MathML;
use strict;
use LaTeXML::Common::XML;
use base qw(LaTeXML::Post::MathProcessor);

our $mmlURI = "http://www.w3.org/1998/Math/MathML";

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# See END for specific converters.
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Top level
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sub preprocess {
  my($self,$doc,@nodes)=@_;
  $doc->adjust_latexml_doctype('MathML');  # Add MathML if LaTeXML dtd.
  $doc->addNamespace($mmlURI,'m'); }

# Works for pmml, cmml
sub outerWrapper {
  my($self,$doc,$node,@conversion)=@_;
  my $mode = $node->getAttribute('mode')||'inline';
  ['m:math',{display=>($mode eq 'display' ? 'block' : 'inline'),
	     alttext=>$node->getAttribute('tex') },
   @conversion]; }

sub keepTeX {
 my($self)=@_;
  $$self{keepTeX}=1;}

sub find_math_nodes {  $_[1]->findnodes('//ltx:Math'); }

# This works for either pmml or cmml.
sub combineParallel {
  my($self,$doc,$math,$primary,@secondaries)=@_;
  my $tex = isElementNode($math) && $math->getAttribute('tex');
  (['m:semantics',{},
    $primary,
    map( ['m:annotation-xml',{encoding=>$$_[0]->getEncodingName},$$_[1]], @secondaries),
    (defined $tex ? (['m:annotation',{encoding=>'application/x-tex'}, $tex]) : ()) ]); }

# $self->convertNode($doc,$node);
# will be handled by specific Presentation or Content MathML converters; See at END.

# $self->translateNode($doc,$XMath,$style,$embedding)
# returns the translation of the XMath node (but doesn't insert it)
# $style will be either 'display' or 'text' (if relevant),
# The result should be wrapped as necessary for the result to
# be embedded within the tag $embedding.
# Eg. for parallel markup.

# See END for presentation, content and parallel versions.

sub getQName {
  $LaTeXML::Post::DOCUMENT->getQName(@_); }

# Hook for subclasses to annotate the transformation.
sub augmentNode {
  my($self,$node,$mathml)=@_;
  $mathml; }

# Add a cross-reference linkage (eg. xref) onto $node to refer to the given $id.
# (presumably $id is the id of a node created by another Math Postprocessor
# from the same source XMath node that generated $node)
sub addCrossref {
  my($self,$node,$id)=@_;
  $node->setAttribute(xref=>$id); }

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# General translation utilities.
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sub realize {
  my($node)=@_;
  $LaTeXML::Post::DOCUMENT->realizeXMNode($node); }

# For a node that is a (possibly embellished) operator,
# find the underlying role.
our %EMBELLISHING_ROLE=(SUPERSCRIPTOP=>1,SUBSCRIPTOP=>1,STACKED=>1,
			OVERACCENT=>1,UNDERACCENT=>1,MODIFIER=>1,MODIFIEROP=>1);
sub getOperatorRole {
  my($node)=@_;
  if(!$node){
    undef; }
  elsif(my $role = $node->getAttribute('role')){
    $role; }
  elsif(getQName($node) eq 'ltx:XMApp'){
    my($op,$base)= element_nodes($node);
    ($EMBELLISHING_ROLE{$op->getAttribute('role')||''}
     ? getOperatorRole($base)
     : undef); }}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Table of Translators for presentation|content
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# All translators take XMath XML::LibXML nodes as arguments,
# and return an intermediate form (ie. array form) of MathML to be added.

our $MMLTable_P={};
our $MMLTable_C={};

sub DefMathML {
  my($key,$presentation,$content) =@_;
  $$MMLTable_P{$key} = $presentation if $presentation;
  $$MMLTable_C{$key} = $content if $content; }

sub lookupPresenter {
  my($mode,$role,$name)=@_;
  $name = '?' unless $name;
  $role = '?' unless $role;
  $$MMLTable_P{"$mode:$role:$name"} || $$MMLTable_P{"$mode:?:$name"}
    || $$MMLTable_P{"$mode:$role:?"} || $$MMLTable_P{"$mode:?:?"}; }

sub lookupContent {
  my($mode,$role,$name)=@_;
  $name = '?' unless $name;
  $role = '?' unless $role;
  $$MMLTable_C{"$mode:$role:$name"} || $$MMLTable_C{"$mode:?:$name"}
    || $$MMLTable_C{"$mode:$role:?"} || $$MMLTable_C{"$mode:?:?"}; }


#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Various needed maps
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
our %stylestep=(display=>'text', text=>'script',
	       script=>'scriptscript', scriptscript=>'scriptscript');
our %style_script_step=(display=>'script', text=>'script',
	       script=>'scriptscript', scriptscript=>'scriptscript');
our %stylemap
  = (display     =>{text        =>[displaystyle=>'false'],
		    script      =>[displaystyle=>'false',scriptlevel=>'+1'],
		    scriptscript=>[displaystyle=>'false',scriptlevel=>'+2']},
     text        =>{display     =>[displaystyle=>'true'],
		    script      =>[scriptlevel=>'+1'],
		    scriptscript=>[scriptlevel=>'+2']},
     script      =>{display     =>[displaystyle=>'true',scriptlevel=>'-1'],
		    text        =>[scriptlevel=>'-1'],
		    scriptscript=>[scriptlevel=>'+1']},
     scriptscript=>{display     =>[displaystyle=>'true',scriptlevel=>'-2'],
		    text        =>[scriptlevel=>'-2'],
		    script      =>[scriptlevel=>'-1']});

# Mappings between internal fonts & sizes.
# Default math font is roman|medium|upright.
our %mathvariants = ('upright'          =>'normal',
		     'serif'            =>'normal',
		     'medium'           =>'normal',
		     'bold'             =>'bold',
		     'bold upright'     =>'bold',
		     'serif bold'       =>'bold',
		     'serif bold upright'=>'bold',
		     'italic'           =>'italic',
		     'slanted'          =>'italic',
		     'serif italic'     =>'italic',
		     'serif slanted'    =>'italic',
		     'medium italic'    =>'italic',
		     'medium slanted'   =>'italic',
		     'bold italic'      =>'bold-italic',
		     'bold slanted'     =>'bold-italic',
		     'serif bold italic'=>'bold-italic',
		     'serif bold slanted'=>'bold-italic',
		     'doublestruck'     =>'double-struck',
		     'doublestruck upright'=>'double-struck',
		     'blackboard'       =>'double-struck',
		     'blackboard upright'=>'double-struck',
		     'fraktur'          => 'fraktur',
		     'fraktur italic'   => 'fraktur', # ?
		     'fraktur slanted'  => 'fraktur', # ?
		     'fraktur upright'  => 'fraktur',
		     'fraktur bold'     => 'bold-fraktur',
		     'script'           => 'script',
		     'script italic'    => 'script',
		     'script slanted'   => 'script',
		     'script upright'   => 'script',
		     'script bold'      => 'bold-script',
		     'caligraphic'      => 'script',
		     'caligraphic upright'=> 'script',
		     'caligraphic bold' => 'bold-script',
		     'sansserif'        => 'sans-serif',
		     'sansserif upright'=> 'sans-serif',
		     'sansserif bold'   => 'bold-sans-serif',
		     'sansserif italic' => 'sans-serif-italic',
		     'sansserif slanted'=> 'sans-serif-italic',
		     'sansserif bold italic'  => 'sans-serif-bold-italic',
		     'sansserif bold slanted' => 'sans-serif-bold-italic',
		     'typewriter'       => 'monospace');

# The font differences (from the containing context) have been deciphered
# into font, size and color attributes.  The font should match
# one of the above... (?)
our %sizes=(tiny=>'small',script=>'small',footnote=>'small',small=>'small',
	    normal=>'normal',
	    large=>'big',Large=>'big',LARGE=>'big',huge=>'big',Huge=>'big',
	    big=>'1.1em', Big=>'1.5em', bigg=>'2.0em', Bigg=>'2.5em');

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Support functions for Presentation MathML
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sub pmml_top {
  my($self,$node,$style)=@_;
  # These bindings reflect the style, font, size & color that we are displaying in.
  # Ie. if you want to draw in that size & color, you'll get it automatically.
  local $LaTeXML::MathML::STYLE = $style;
  local $LaTeXML::MathML::FONT    = find_inherited_attribute($node,'font');
  $LaTeXML::MathML::FONT = undef
    if $LaTeXML::MathML::FONT && !$mathvariants{$LaTeXML::MathML::FONT}; # verify sane font
  local $LaTeXML::MathML::SIZE    = find_inherited_attribute($node,'fontsize');
  local $LaTeXML::MathML::COLOR   = find_inherited_attribute($node,'color');
  local $LaTeXML::MathML::BGCOLOR = find_inherited_attribute($node,'backgroundcolor');
  local $LaTeXML::MathML::OPACITY = find_inherited_attribute($node,'opacity');
  pmml($node); }

sub find_inherited_attribute {
  my($node,$attribute)=@_;
  while($node && isElementNode($node)){
    if(my $value = $node->getAttribute($attribute)){
      return $value; }
    $node = $node->parentNode; }
  return undef; }

# Convert a node that will automatically be made smaller, due to its context,
# such as in the numerator or denominator of a fraction.
sub pmml_smaller {
  my($node)=@_;
  local $LaTeXML::MathML::STYLE = $stylestep{$LaTeXML::MathML::STYLE};
  pmml($node); }

# Convert a node that will automatically be made scriptsize,
# such as sub- or superscripts.
sub pmml_scriptsize {
  my($script)=@_;
  local $LaTeXML::MathML::STYLE = $style_script_step{$LaTeXML::MathML::STYLE};
  ($script ? pmml($script) : ['m:none']); }

sub pmml {
  my($node)=@_;
  my $o = $node->getAttribute('open');
  my $c = $node->getAttribute('close');
  my $e = $node->getAttribute('enclose');
  my $p = $node->getAttribute('punctuation');
  # Do the core conversion.
  my $result = (getQName($node) eq 'ltx:XMRef'
		? pmml(realize($node))
		: $LaTeXML::Post::MATHPROCESSOR->augmentNode($node,pmml_internal($node)));
  # Handle generic things: open/close delimiters, punctuation
  $result = pmml_parenthesize($result,$o,$c) if $o || $c;
  $result = ['m:menclose',{notation=>$e},$result] if $e;
  $result = ['m:mrow',{},$result,pmml_mo($p)] if $p;
  # map any ID here, as well,
  # BUT, since we follow split/scan, use the fragid, not xml:id! TO SOLVE LATER
  # We alter the id for the newly created node, as appropriate for the current format.
  # We MAY want to build a richer bi-directional (or multi-directional?) linkage,
  # so that we know which nodes from separate are associated with each other.
  # ACTUALLY, the association can be n:1 (eg infix +) or 1:m (eg integration) (maybe n:m ???)
  # At any rate, we'll want to record that the "source id" $id gave rise to $pmmlid
  # Then later on, a processor might make the reverse connections????
###  if(my $id = $node->getAttribute('fragid')){
###    my $pmmlid = $id.$LaTeXML::Post::MATHPROCESSOR->IDSuffix;
###    $$result[1]{'xml:id'}=$pmmlid; }

  if(my $id = $LaTeXML::Post::MATHPROCESSOR->convertID($node->getAttribute('fragid'))){
    $$result[1]{'xml:id'}=$id; }

  $result; }

our $NBSP = pack('U',0xA0);

sub pmml_internal {
  my($node)=@_;
  return ['m:merror',{},['m:mtext',{},"Missing Subexpression"]] unless $node;
  my $tag = getQName($node);
  my $role = $node->getAttribute('role');
  if($tag eq 'ltx:XMath'){
    pmml_row(map(pmml($_), element_nodes($node))); } # Really multiple nodes???
  elsif($tag eq 'ltx:XMDual'){
    my($content,$presentation) = element_nodes($node);
    pmml($presentation); }
  elsif(($tag eq 'ltx:XMWrap')||($tag eq 'ltx:XMArg')){	# Only present if parsing failed!
    pmml_row(map(pmml($_),element_nodes($node))); }
  elsif($tag eq 'ltx:XMApp') {
    my($op,@args) = element_nodes($node);
    if(!$op){
      ['m:merror',{},['m:mtext',{},"Missing Operator"]]; }
    elsif($role && ($role =~ /^(FLOAT|POST)(SUB|SUPER)SCRIPT$/)){
      # (FLOAT|POST)(SUB|SUPER)SCRIPT's should NOT remain in successfully parsed math.
      # This conversion creates something "presentable", though doubtfully correct (empty mi?)
      # Really should mark & make a fake parsing pass to & group open/close pairs & attach scripts
      [ ($2 eq 'SUB' ? 'm:msub' : 'm:msup' ), {}, ['m:mi'],
	pmml_scriptsize($op)]; }
    else {
      my $rop = realize($op);  # NOTE: Could loose open/close on XMRef ???
      my $style = $op->getAttribute('fracstyle');
      my $styleattr = $style && $stylemap{$LaTeXML::MathML::STYLE}{$style};
      local $LaTeXML::MathML::STYLE 
	= ($style && $stylestep{$style} ? $style : $LaTeXML::MathML::STYLE);
      my $result = &{ lookupPresenter('Apply',getOperatorRole($rop),$rop->getAttribute('meaning'))
		    }($op,@args);
      $result = ['m:mstyle',{@$styleattr},$result] if $styleattr;
      $result; }
  } 
  elsif($tag eq 'ltx:XMTok'){
    &{ lookupPresenter('Token',$role,$node->getAttribute('meaning')) }($node); }
  elsif($tag eq 'ltx:XMHint'){
    &{ lookupPresenter('Hint',$role,$node->getAttribute('meaning')) }($node); }
  elsif($tag eq 'ltx:XMArray'){
    my $style = $node->getAttribute('fracstyle');
    my $styleattr = $style && $stylemap{$LaTeXML::MathML::STYLE}{$style};
    local $LaTeXML::MathML::STYLE 
      = ($style && $stylestep{$style} ? $style : $LaTeXML::MathML::STYLE);
    my @rows = ();
    foreach my $row (element_nodes($node)){
      my @cols = ();
      foreach my $col (element_nodes($row)){
	my $a = $col->getAttribute('align');
	my $b = $col->getAttribute('border');
	my $h = (($col->getAttribute('thead')||'') eq 'true') && 'thead';
	my $c = ($b ? ($h ? "$b $h" : $b) : $h);
	my $cs = $col->getAttribute('colspan');
	my $rs = $col->getAttribute('rowspan');
	push(@cols,['m:mtd',{($a ? (columnalign=>$a):()),
			     ($c ? (class=>$c):()),
			     ($cs ? (columnspan=>$cs):()),
			     ($rs ? (rowspan=>$rs):())},
		    map(pmml($_),element_nodes($col))]); }
      push(@rows,['m:mtr',{},@cols]); }
    my $result = ['m:mtable',{rowspacing=>"0.2ex", columnspacing=>"0.4em"},@rows];
    $result = ['m:mstyle',{@$styleattr},$result] if $styleattr;
    $result; }
  #Experimental XMRow and XMCell support.
  #DG: We should accommodate XMRow and XMCell elements appearing out of Arrays (sTeX notations)
  elsif($tag eq 'ltx:XMRow'){
    my $style = $node->getAttribute('style');
    my $styleattr = $style && $stylemap{$LaTeXML::MathML::STYLE}{$style};
    local $LaTeXML::MathML::STYLE 
      = ($style && $stylestep{$style} ? $style : $LaTeXML::MathML::STYLE);
    my @cols = ();
    foreach my $col (element_nodes($node)){
    my $a = $col->getAttribute('align');
    my $b = $col->getAttribute('border');
    my $h = (($col->getAttribute('thead')||'') eq 'true') && 'thead';
    my $c = ($b ? ($h ? "$b $h" : $b) : $h);
    my $cs = $col->getAttribute('colspan');
    my $rs = $col->getAttribute('rowspan');
    push(@cols,['m:mtd',{($a ? (columnalign=>$a):()),
                        ($c ? (class=>$c):()),
                        ($cs ? (columnspan=>$cs):()),
                        ($rs ? (rowspan=>$rs):())},
                      map(pmml($_),element_nodes($col))]); }
    my $result = ['m:mtr',{},@cols];
    $result = ['m:mstyle',{@$styleattr},$result] if $styleattr;
    $result; }
  elsif($tag eq 'ltx:XMCell'){
    my $style = $node->getAttribute('style');
    my $styleattr = $style && $stylemap{$LaTeXML::MathML::STYLE}{$style};
    local $LaTeXML::MathML::STYLE 
      = ($style && $stylestep{$style} ? $style : $LaTeXML::MathML::STYLE);
    my $col = $node;
    my $a = $col->getAttribute('align');
    my $b = $col->getAttribute('border');
    my $h = (($col->getAttribute('thead')||'') eq 'true') && 'thead';
    my $c = ($b ? ($h ? "$b $h" : $b) : $h);
    my $cs = $col->getAttribute('colspan');
    my $rs = $col->getAttribute('rowspan');
    my $result = ['m:mtd',{($a ? (columnalign=>$a):()),
                        ($c ? (class=>$c):()),
                        ($cs ? (columnspan=>$cs):()),
                        ($rs ? (rowspan=>$rs):())},
                      map(pmml($_),element_nodes($col))];
    $result = ['m:mstyle',{@$styleattr},$result] if $styleattr;
    $result; }
  elsif($tag eq 'ltx:XMText'){
    pmml_row(map(pmml_text_aux($_), $node->childNodes)); }
  else {
    my $text = $node->textContent; #  Spaces are significant here
    $text =~ s/^\s+/$NBSP/;
    $text =~ s/\s+$/$NBSP/;
    ['m:mtext',{},$text]; }}

sub pmml_row {
  my(@items)=@_;
  @items = grep($_,@items);
  (scalar(@items) == 1 ? $items[0] : ['m:mrow',{},@items]); }

sub pmml_unrow {
  my($mml)=@_;
  if($mml && (ref $mml)  && ($mml->[0] eq 'm:mrow') && !scalar(keys %{$mml->[1]})){
    my($tag,$attr,@children)=@$mml;
    @children; }
  else {
    ($mml); }}

sub pmml_parenthesize {
  my($item,$open,$close)=@_;
  if(!$open && !$close){
    $item; }
  # OR, maybe we should just use mfenced?
  # mfenced is better for CSS profile.
  # when the insides are line-broken, induces a less traditional appearance
  # (however, line-breaking inside of a mrow w/parens needs some special treatment too! scripts!!)
  else {
    ['m:mfenced', {open=>($open||''), close=>($close||'')}, $item]; }}
## Maybe better not open the contained mrow; seems to affect bracket size in Moz.???
  # elsif($item && (ref $item)  && ($item->[0] eq 'm:mrow')){
  #   my($tag,$attr,@children)=@$item;
  #   ['m:mrow',$attr,
  #    ($open ? (pmml_mo($open)):()),
  #    @children,
  #    ($close ? (pmml_mo($close)):())]; }
  # else {
  #   ['m:mrow',{},
  #    ($open ? (pmml_mo($open,role=>'OPEN')):()),
  #    $item,
  #    ($close ? (pmml_mo($close,role=>'CLOSE')):())]; }}

sub pmml_punctuate {
  my($separators,@items)=@_;
  $separators='' unless defined $separators;
  my $lastsep=', ';
  my @arglist;
  if(@items){
    push(@arglist,shift(@items));
    while(@items){
      $separators =~ s/^(.)//;
      $lastsep = $1 if $1;
      push(@arglist,pmml_mo($lastsep),shift(@items)); }}
  pmml_row(@arglist); }


# args are XMath nodes
# This is suitable for use as an Apply handler.
sub pmml_infix {
  my($op,@args)=@_;
  $op = realize($op);
  return ['m:mrow',{}] unless $op && @args; # ??
  my @items=();
  if(scalar(@args) == 1){	# Infix with 1 arg is presumably Prefix!
    push(@items,(ref $op ? pmml($op) : pmml_mo($op)),pmml($args[0])); }
  else {
    ## push(@items, pmml(shift(@args)));
    # Experiment at flattening?
    my $role = getOperatorRole($op);
    my $arg1 = realize(shift(@args));
    if(($role eq 'ADDOP')
       && (getQName($arg1) eq 'ltx:XMApp')
       && !$arg1->getAttribute('open') && !$arg1->getAttribute('close')
       && (getOperatorRole((element_nodes($arg1))[0]) eq $role)){
      push(@items, pmml_unrow(pmml($arg1))); }
    else {
      push(@items, pmml($arg1)); }
    while(@args){
      push(@items,(ref $op ? pmml($op) : pmml_mo($op)));
      push(@items,pmml(shift(@args))); }}
  pmml_row(@items); }

sub UTF {
  my($code)=@_;
  pack('U',$code); }

sub makePlane1Map {
  my($latin,$GREEK,$greek,$digits)=@_; 
  ( map( (UTF(ord('A')+ $_)=>UTF($latin + $_)), 0..25),
    map( (UTF(ord('a')+ $_)=>UTF($latin + 26 + $_)), 0..25),
    ($GREEK ? map( (UTF(0x0391+ $_)=>UTF($GREEK + $_)), 0..24) : ()),
    ($greek ? map( (UTF(0x03B1+ $_)=>UTF($greek + $_)), 0..24) : ()),
    ($digits ? map( (UTF(ord('0')+ $_)=>UTF($digits + $_)), 0..9) : ())); }

our %plane1map =
     ('bold'                  =>{makePlane1Map(0x1D400,0x1D6A8,0x1D6C2,0x1D7CE)},
      'italic'                =>{makePlane1Map(0x1D434,0x1D6E2,0x1D6FC, undef),
				h=>"\x{210E}"},
      'bold-italic'           =>{makePlane1Map(0x1D468,0x1D71C,0x1D736, undef)},
      'sans-serif'            =>{makePlane1Map(0x1D5A0, undef,  undef, 0x1D7E2)},
      'bold-sans-serif'       =>{makePlane1Map(0x1D5D4,0x1D756,0x1D770,0x1D7EC)},
      'sans-serif-italic'     =>{makePlane1Map(0x1D608, undef,  undef,  undef)},
      'sans-serif-bold-italic'=>{makePlane1Map(0x1D63C,0x1D790,0x1D7AA, undef)},
      'monospace'             =>{makePlane1Map(0x1D670, undef,  undef, 0x1D7F6)},
      'script'                =>{makePlane1Map(0x1D49C, undef,  undef,  undef),
				 B=>"\x{212C}",E=>"\x{2130}",F=>"\x{2131}",H=>"\x{210B}",I=>"\x{2110}",
				 L=>"\x{2112}",M=>"\x{2133}",R=>"\x{211B}",
				 e=>"\x{212F}",g=>"\x{210A}",o=>"\x{2134}"},
      'bold-script'           =>{makePlane1Map(0x1D4D0, undef,  undef,  undef)},
      'fraktur'               =>{makePlane1Map(0x1D504, undef,  undef,  undef),
				 C=>"\x{212D}",H=>"\x{210C}",I=>"\x{2111}",R=>"\x{211C}", Z=>"\x{2128}"},
      'bold-fraktur'          =>{makePlane1Map(0x1D56C, undef,  undef,  undef)},
      'double-struck'         =>{makePlane1Map(0x1D538, undef,  undef, 0x1D7D8),
				 C=>"\x{2102}",H=>"\x{210D}",N=>"\x{2115}",P=>"\x{2119}",Q=>"\x{211A}",
				 R=>"\x{211D}",Z=>"\x{2124}"}
    );

our %plane1hack = (script=>$plane1map{script},  'bold-script'=>$plane1map{script},
		   fraktur=>$plane1map{fraktur},'bold-fraktur'=>$plane1map{fraktur},
		   'double-struck'=>$plane1map{'double-struck'});

# Given an item (string or token element w/attributes) and latexml attributes,
# convert the string to the appropriate unicode (possibly plane1)
# & MathML presentation attributes (mathvariant, mathsize, mathcolor, stretchy)
# $mihack is a boolean whether to apply mi's special case rule for single character identifier.
sub stylizeContent {
  my($item,$mihack,%attr)=@_;
  my $iselement = (ref $item) eq 'XML::LibXML::Element';
  my $font  = ($iselement ? $item->getAttribute('font') : $attr{font})
    || $LaTeXML::MathML::FONT;
  my $size  = ($iselement ? $item->getAttribute('fontsize') : $attr{fontsize})
    || $LaTeXML::MathML::SIZE;
  my $color = ($iselement ? $item->getAttribute('color') : $attr{color})
    || $LaTeXML::MathML::COLOR;
  my $bgcolor = ($iselement ? $item->getAttribute('backgroundcolor') : $attr{backgroundcolor})
    || $LaTeXML::MathML::BGCOLOR;
  my $opacity = ($iselement ? $item->getAttribute('opacity') : $attr{opacity})
    || $LaTeXML::MathML::OPACITY;
  my $text  = (ref $item  ?  $item->textContent : $item);
  my $variant = ($font ? $mathvariants{$font} : '');
  my $stretchy = $size && ($size eq 'stretchy'); # sort-of a size... (but only for operators?)
  $size = undef if $stretchy;			 # but then don't need regular sizing.
  # Hack to neutralize unnecessary sizing
  $size = undef if $size && ($size eq $LaTeXML::MathML::STYLE);

  # Failsafe for empty tokens?
  if((! defined $text) || ($text eq '')){
    $text = ($iselement ? $item->getAttribute('name') || $item->getAttribute('meaning') || $item->getAttribute('role') : '?');
    $color = 'red'; }

  if($font && !$variant){
    warn "Unrecognized font variant \"$font\""; $variant=''; }
  # Special case for single char identifiers?
  if($mihack && ($text =~ /^.$/)){	# Single char in mi?
    if($variant eq 'italic'){ $variant = undef; } # Defaults to italic
    elsif(!$variant){ $variant = 'normal'; }}  # must say so explicitly.

  # Should we map to Unicode's Plane 1 blocks for Mathematical Alphanumeric Symbols?
  # Only upper & lower case latin & greek, and also numerals can be mapped.
  # For each mathvariant, and for each of those 5 groups, there is a linear mapping,
  # EXCEPT for chars defined before Plain 1, which already exist in lower blocks.
  my $mapping;
  # Get desired mapping strategy
  my $plane1= $$LaTeXML::Post::MATHPROCESSOR{plane1};
  my $plane1hack= $$LaTeXML::Post::MATHPROCESSOR{hackplane1};
  if($variant
     && ($plane1 || $plane1hack)
     && ($mapping = ($plane1hack ? $plane1hack{$variant} : $plane1map{$variant}))){
    my @c = map($$mapping{$_}, split(//,$text));
    if(! grep(! defined $_, @c)){ # Only if ALL chars in the token could be mapped... ?????
      $text = join('',@c);
      $variant = ($plane1hack && ($variant =~ /^bold/) ? 'bold' : undef);  }}
###  ($text,$variant,$size && $sizes{$size},$color); }
  ($text,
   ($variant  ? (mathvariant=>$variant):()),
   ($size     ? (mathsize=>$sizes{$size})  :()),
   ($color    ? (mathcolor=>$color):()),
   ($bgcolor  ? (mathbackground=>$bgcolor):()),
   ($opacity  ? (style=>"opacity:$opacity"):()), # ???
   ($stretchy ? (stretchy=>'true'):())   ); }


# These are the strings that should be known as fences in a normal operator dictionary.
our %fences=('('=>1,')'=>1, '['=>1, ']'=>1, '{'=>1, '}'=>1, "\x{201C}"=>1,"\x{201D}"=>1,
	     "\`"=>1, "'"=>1, "<"=>1,">"=>1,
	     "\x{2329}"=>1,"\x{232A}"=>1, # angle brackets; NOT mathematical, but balance in case they show up.
	     "\x{27E8}"=>1,"\x{27E9}"=>1, # angle brackets (prefered)
	     "\x{230A}"=>1, "\x{230B}"=>1, "\x{2308}"=>1,"\x{2309}"=>1);


sub pmml_mpadded {
  my($item,$rspace)=@_;
  ($rspace
   ? ['m:mpadded', {width=>($rspace=~/^-/ ? $rspace : '+'.$rspace)}, $item]
   : $item); }

# Generally, $item in the following ought to be a string.
sub pmml_mi {
  my($item,%attr)=@_;
  my($text,%mmlattr)=stylizeContent($item,1,%attr);
  pmml_mpadded( ['m:mi', {%mmlattr}, $text],
		(ref $item) && $item->getAttribute('rspace')); }

# Really, the same issues as with mi.
sub pmml_mn {
  my($item,%attr)=@_;
  my($text,%mmlattr)=stylizeContent($item,0,%attr);
  pmml_mpadded( ['m:mn', {%mmlattr}, $text],
		(ref $item) && $item->getAttribute('rspace')); }

# Note that $item should be either a string, or at most, an XMTok
sub pmml_mo {
  my($item,%attr)=@_;
  my($text,%mmlattr)=stylizeContent($item,0,%attr);
  my $role  = (ref $item ? $item->getAttribute('role') : $attr{role});
  my $isfence = $role && ($role =~/^(OPEN|CLOSE)$/);
  my $lspace  = $role && ($role eq 'MODIFIEROP') && 'mediummathspace';
  my $rspace  = $role && ($role eq 'MODIFIEROP') && 'mediummathspace';
  my $pos   = (ref $item && $item->getAttribute('scriptpos')) || 'post';
  pmml_mpadded( ['m:mo',{%mmlattr,
			 ($isfence && !$fences{$text} ? (fence=>'true'):()),
			 ($lspace  ? (lspace=>$lspace):()),
			 ($rspace  ? (rspace=>$rspace):()),
			 # If an operator has specifically located it's scripts,
			 # don't let mathml move them.
			 (($pos =~ /mid/) || $LaTeXML::MathML::NOMOVABLELIMITS
			  ? (movablelimits=>'false'):())},
		 $text],
		(ref $item) && $item->getAttribute('rspace')); }

# Since we're keeping track of display style, under/over vs. sub/super
# We've got to override MathML's desire to do it for us.
# Here, we make sure the eventual inner operator (if any) has
# movablelimits disabled.
# NOTE: Another issue is when the base is "embellished", in particular
# has sub/superscripts of it's own.
# Mozilla (at least?) centers the over/under wrong in that case.
# The OVERUNDERHACK makes the sub & superscripts have 0 width 
# in this situation.
# Worried that this will end up biting me, though...
sub pmml_script_overunder_aux {
  my($tag,$base,@scripts)=@_;
  { local $LaTeXML::MathML::NOMOVABLELIMITS=1;
    local $LaTeXML::MathML::OVERUNDERHACKS=1;
    $base = pmml($base); }
  [$tag,{},$base, map(pmml_scriptsize($_),@scripts)]; }

sub pmml_script_subsup_aux {
  my($tag,$base,@scripts)=@_;
  $base = pmml($base);
  @scripts = map(pmml_scriptsize($_),@scripts);
  if($LaTeXML::MathML::OVERUNDERHACKS){
    @scripts = map(['m:mpadded',{width=>'0'},$_],@scripts); }
  [$tag,{},$base,@scripts]; }

sub pmml_script {
  my($op,$base,$script)=@_;
  my(@pres,@posts);
  my($prelevel,$postlevel)=(0,0);
  my ($y) = ($op->getAttribute('role')||'') =~ /^(SUPER|SUB)SCRIPTOP$/;
  my ($x,$l)= ($op->getAttribute('scriptpos')||'post0')
    =~ /^(pre|mid|post)?(\d+)?$/;
  if($x eq 'pre'){
    if($y eq 'SUB'){
      push(@pres,[$script,undef]); $prelevel=$l; }
    elsif($y eq 'SUPER'){
      push(@pres,[undef,$script]); $prelevel=$l; }}
  else {
    if($y eq 'SUB'){
      push(@posts,[$script,undef]); $postlevel=$l; }
    elsif($y eq 'SUPER'){
      push(@posts,[undef,$script]); $postlevel=$l; }}

  # Examine $base to see if there are nested scripts.
  # We'll fold them together they seem to be on the appropriate levels
  # Keep from having multiple scripts when $loc is stack!!!
  while(1){
    last unless getQName($base) eq 'ltx:XMApp';
    last if $base->getAttribute('open') || $base->getAttribute('close');
    my($xop,$xbase,$xscript) = element_nodes($base);
    last unless (getQName($xop) eq 'ltx:XMTok');
    my ($ny) = ($xop->getAttribute('role')||'') =~ /^(SUPER|SUB)SCRIPTOP$/;
    last unless $ny;
    my ($nx,$nl)= ($xop->getAttribute('scriptpos')||'post0')
      =~ /^(pre|mid|post)?(\d+)?$/;
#    last unless ($x ne 'mid') || ($nx eq 'mid');
    # what did that mean? Doesn't it mean this???
    last if ($x eq 'mid') || ($nx eq 'mid');

    my $spos = ($ny eq 'SUB' ? 0 : 1);
    if($nx eq 'pre'){
      push(@pres,[undef,undef]) # New empty pair (?)
	if($prelevel ne $nl) || $pres[-1][$spos];
      $pres[-1][$spos] = $xscript; $prelevel = $nl; }
    else {
      unshift(@posts,[undef,undef]) # New empty pair (?)
	if($postlevel ne $nl) || $posts[0][$spos];
      $posts[0][$spos] = $xscript; $postlevel = $nl; }
    $base = $xbase;
  }
  if(scalar(@pres) > 0){
    ['m:mmultiscripts',{},
     pmml($base),
     map( (pmml_scriptsize($_->[0]),pmml_scriptsize($_->[1])), @posts),
     ['m:mprescripts'],
     map( (pmml_scriptsize($_->[0]),pmml_scriptsize($_->[1])), @pres)]; }
  elsif(scalar(@posts) > 1){
    ['m:mmultiscripts',{},
     pmml($base),
     map( (pmml_scriptsize($_->[0]),pmml_scriptsize($_->[1])), @posts)]; }
  elsif(!defined $posts[0][1]){
    if($x eq 'mid'){ pmml_script_overunder_aux('m:munder',$base,$posts[0][0]); }
    else           { pmml_script_subsup_aux('m:msub',$base,$posts[0][0]); }}
  elsif(!defined $posts[0][0]){
    if($x eq 'mid'){ pmml_script_overunder_aux('m:mover',$base,$posts[0][1]); }
    else           { pmml_script_subsup_aux('m:msup',$base,$posts[0][1]); }}
  else {
    if($x eq 'mid'){ pmml_script_overunder_aux('m:munderover',$base,$posts[0][0],$posts[0][1]); }
    else           { pmml_script_subsup_aux('m:msubsup',$base,$posts[0][0],$posts[0][1]); }}}

# Handle text contents.
# Note that (currently) MathML doesn't allow math nested in m:mtext,
# nor in fact any other markup within m:mtext,
# but LaTeXML creates that, if the document is structured that way.
# Here we try to flatten the contents to strings, but keep the math as math
sub pmml_text_aux {
  my($node,%attr)=@_;
  return () unless $node;
  my $type = $node->nodeType;
  if($type == XML_TEXT_NODE){
    my($string,%mmlattr)=stylizeContent($node,0,%attr);
    $string =~ s/^\s/$NBSP/;     $string =~ s/\s$/$NBSP/;
    ['m:mtext', {%mmlattr}, $string]; }
  elsif($type == XML_DOCUMENT_FRAG_NODE){
    map(pmml_text_aux($_,%attr), $node->childNodes); }
  elsif($type == XML_ELEMENT_NODE){
    if(my $font    = $node->getAttribute('font'))           { $attr{font} = $font; }
    if(my $size    = $node->getAttribute('fontsize'))       { $attr{fontsize} = $size; }
    if(my $color   = $node->getAttribute('color'))          { $attr{color} = $color; }
    if(my $bgcolor = $node->getAttribute('backgroundcolor')){ $attr{backgroundcolor} = $bgcolor; }
    if(my $opacity = $node->getAttribute('opacity'))        { $attr{opacity} = $opacity; }
    my $tag = getQName($node);
    if($tag eq 'ltx:Math'){
      my $xmath = $LaTeXML::Post::DOCUMENT->findnode('ltx:XMath',$node);
      # NOTE BUG!!! we're not passing through the context... (but maybe pick it up anyway)
      ($xmath ? pmml($xmath) : ()); }
    else {			# Just recurse on raw content????
      map(pmml_text_aux($_,%attr), $node->childNodes); }}
  else {
    (); }}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Support functions for Content MathML
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sub cmml_top {
  my($self,$node)=@_;
  local $LaTeXML::MathML::STYLE = 'text';
  local $LaTeXML::MathML::FONT  = find_inherited_attribute($node,'font');
#  $LaTeXML::MathML::FONT = undef unless $mathvariants{$LaTeXML::MathML::FONT}; # Make sure it's a sane font
  local $LaTeXML::MathML::SIZE    = find_inherited_attribute($node,'fontsize');
  local $LaTeXML::MathML::COLOR   = find_inherited_attribute($node,'color');
  local $LaTeXML::MathML::BGCOLOR = find_inherited_attribute($node,'backgroundcolor');
  local $LaTeXML::MathML::OPACITY = find_inherited_attribute($node,'opacity');
  cmml($node); }

sub cmml {
  my($node)=@_;
  my $result = cmml_internal($node);
  # map any ID here, as well, BUT, since we follow split/scan, use the fragid, not xml:id!
###  if(my $id = $node->getAttribute('fragid')){
###    $$result[1]{'xml:id'}=$id.$LaTeXML::Post::MATHPROCESSOR->IDSuffix; }
  if(my $id = $LaTeXML::Post::MATHPROCESSOR->convertID($node->getAttribute('fragid'))){
    $$result[1]{'xml:id'}=$id; }
  $result; }

sub cmml_internal {
  my($node)=@_;
  return ['m:merror',{},['m:mtext',{},"Missing Subexpression"]] unless $node;
  $node = realize($node) if getQName($node) eq 'ltx:XMRef';
  my $tag = getQName($node);
  if($tag eq 'ltx:XMath'){
    my($item,@rest)=  element_nodes($node);
    if(@rest){			# Unparsed ???
      cmml_unparsed($item,@rest); }
    else {
      cmml($item); }}
  elsif($tag eq 'ltx:XMDual'){
    my($content,$presentation) = element_nodes($node);
    cmml($content); }
  elsif(($tag eq 'ltx:XMWrap')||($tag eq 'ltx:XMArg')){	# Only present if parsing failed!
    cmml_unparsed(element_nodes($node)); }
  elsif($tag eq 'ltx:XMApp'){
    # Experiment: If XMApp has role ID, we treat it as a "Decorated Symbol"
    if(($node->getAttribute('role')||'') eq 'ID'){
      cmml_decoratedSymbol($node); }
    else {
      my($op,@args) = element_nodes($node);
      if(!$op){
	['m:merror',{},['m:mtext',{},"Missing Operator"]]; }
      else {
	my $rop = realize($op);		# NOTE: Could loose open/close on XMRef ???
	&{ lookupContent('Apply',$rop->getAttribute('role'),$rop->getAttribute('meaning')) }($op,@args); }}}
  elsif($tag eq 'ltx:XMTok'){
    &{ lookupContent('Token',$node->getAttribute('role'),$node->getAttribute('meaning')) }($node); }
  elsif($tag eq 'ltx:XMHint'){	# ????
    &{ lookupContent('Hint',$node->getAttribute('role'),$node->getAttribute('meaning')) }($node); }
  else {
    ['m:mtext',{},$node->textContent]; }}

sub cmml_unparsed {
  my(@nodes)=@_;
###  print STDERR "Warning: Got extra nodes for content!\n  ".$node->toString."\n";
## pmml_row(map(pmml($_),@nodes)); } # ????
  ['m:cerror',{},
   ['m:csymbol',{cd=>'ambiguous',name=>'fragments'}],
###   map(cmml($_),@nodes)]; }
   map( ((getQName($_) eq 'ltx:XMTok')&&(($_->getAttribute('role')||'UNKNOWN') eq 'UNKNOWN')
	 ? ['m:csymbol',{cd=>'unknown'},$_->textContent]
	 : cmml($_)),
	@nodes)]; }

# Or csymbol if there's some kind of "defining" attribute?
sub cmml_ci {
  my($item)=@_;
  if(my $meaning = (ref $item) && $item->getAttribute('meaning')){
    my $cd = $item->getAttribute('cd') || 'latexml';
    ['m:csymbol',{cd=>$cd},$meaning]; }
  else {
    my $content = (ref $item ?  $item->textContent : $item);
    ['m:ci',{},$content]; }}

# Experimental; for an XMApp with role=ID, we treat it as a ci
# or ultimately as csymbol, if it had defining attributes,
# but we format its contents as pmml
sub cmml_decoratedSymbol {
  my($item)=@_;
  ['m:ci',{},pmml($item)]; }


# Experimental; for an XMApp with role=CROSSREFOP, we treat it as a mo
# and we format its contents as pmml
# Note that we need to transfer the cr attribute of the XMApp to the m:mo
sub pmml_decoratedOperator {
  my($head,@args)=@_;
  return undef if (!($head->getAttribute('role') eq "CROSSREFOP"));
  my $doc=$LaTeXML::Post::DOCUMENT;
  my $cr  = (ref $head ? $head->getAttribute("cr") : "fun");
  $head->setAttribute("role","SKIP");
  my $operator=pmml(@args);
  return undef unless $operator; #bootstrap
  if ($$operator[0] =~ /^m:m[io]$/) { #Unwrap if only a mi or mo
    $operator=$$operator[2];
    ['m:mo',{'cr'=>$cr},
     $operator]; }
  else {
    #If structure is present, add cr attribute to top level element
    $$operator[1]{'cr'} = $cr;
    $operator;
  }}
#Experiment: CROSSREFOP
DefMathML("Apply:CROSSREFOP:?",       \&pmml_decoratedOperator, undef);
DefMathML("Token:SKIP:?", sub {undef;}, sub{undef;});

# Return the NOT of the argument.
sub cmml_not {
  ['m:apply',{},['m:not',{}],cmml($_[0])]; }

sub cmml_synth_not {
  my($op,@args)=@_;
  ['m:apply',{},['m:not',{}],['m:apply',{},[$op,{}], map(cmml($_),@args)]]; }


# Return the result of converting the arguments, but reversed.
sub cmml_synth_complement {
  my($op,@args)=@_;
  ['m:apply',{},[$op,{}],map(cmml($_),reverse(@args))]; }

# Given an XMath node, Make sure it has an id so it can be shared, then convert to cmml
sub cmml_shared {
  my($node)=@_;
  $LaTeXML::Post::DOCUMENT->generateNodeID($node,'sh');
  cmml($node); }

# Given an XMath node, convert to cmml share form
sub cmml_share {
  my($node)=@_;
  ['m:share',{href=>'#'.$node->getAttribute('fragid').$LaTeXML::Post::MATHPROCESSOR->IDSuffix}]; }

sub cmml_or_compose {
  my($operators,@args)=@_;
  my @operators=@$operators;
  if(scalar(@operators)==1){
    ['m:apply',{},[shift(@operators),{}], map(cmml($_),@args)]; }
  else {
    my @parts=(['m:apply',{},[shift(@operators),{}], map(cmml_shared($_),@args)]);
    foreach my $op (@operators){
      push(@parts,['m:apply',{},[shift(@operators),{}], map(cmml_share($_),@args)]); }
    ['m:or',{},@parts]; }}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Tranlators
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Organized according to the MathML Content element lists.
# As a general rule, presentation conversions are based on role
# (eg "Token:role:?"), whereas content conversions are based
# on meaning or name (eg. "Token:?:meaning").

#======================================================================
# Token elements:
#   cn, ci, csymbol

DefMathML("Token:?:?",           \&pmml_mi, \&cmml_ci);
DefMathML("Token:PUNCT:?",       \&pmml_mo, undef);
DefMathML("Token:PERIOD:?",      \&pmml_mo, undef);
DefMathML("Token:OPEN:?",        \&pmml_mo, undef);
DefMathML("Token:CLOSE:?",       \&pmml_mo, undef);
DefMathML("Token:MIDDLE:?",      \&pmml_mo, undef);
DefMathML("Token:VERTBAR:?",     \&pmml_mo, undef);
DefMathML("Token:ARROW:?",       \&pmml_mo, undef);
DefMathML("Token:OVERACCENT:?",  \&pmml_mo, undef);
DefMathML("Token:UNDERACCENT:?", \&pmml_mo, undef);

DefMathML("Token:NUMBER:?",      \&pmml_mn, sub {
	    my $n = $_[0]->textContent;
	    ['m:cn',{type => ($n=~/^[+-]?\d+$/ ? 'integer' : 'float')},$n]; });

DefMathML("Token:?:absent", sub { ['m:none']} );
DefMathML('Hint:?:?', sub { undef; }, sub { undef; }); # Should Disappear!

# At presentation level, these are essentially adorned tokens.
# args are (accent,base)
DefMathML('Apply:OVERACCENT:?', sub {
  my($accent,$base)=@_;
  ['m:mover',{accent=>'true'}, pmml($base),pmml_scriptsize($accent)]; });

DefMathML('Apply:UNDERACCENT:?', sub {
  my($accent,$base)=@_;
  ['m:munder',{accent=>'true'}, pmml($base),pmml_scriptsize($accent)]; });

#======================================================================
# Basic Content elements:
#   apply, interval, inverse, sep, condition, declare, lambda, compose, ident,
#   domain, codomain, image, domainofapplication, piecewise, piece, otherwise

DefMathML("Token:APPLYOP:?",  \&pmml_mo, undef); # APPLYOP is (only) \x{2061}; FUNCTION APPLICATION
DefMathML("Token:OPERATOR:?", \&pmml_mo, undef);

DefMathML('Apply:?:?', sub {
  my($op,@args)=@_;
  ['m:mrow',{},
   pmml($op),pmml_mo("\x{2061}"),	# FUNCTION APPLICATION
   pmml_parenthesize(pmml_punctuate($op->getAttribute('separators'),map(pmml($_),@args)),
		     $op->getAttribute('argopen'),$op->getAttribute('argclose'))]; },
  sub {
    my($op,@args)=@_;
    ['m:apply',{},cmml($op), map(cmml($_),@args)]; });
DefMathML('Apply:COMPOSEOP:?', \&pmml_infix, undef);

DefMathML("Token:?:open-interval",       undef,sub{['m:interval',{closure=>"open"}];});
DefMathML("Token:?:closed-interval",     undef,sub{['m:interval',{closure=>"closed"}];});
DefMathML("Token:?:closed-open-interval",undef,sub{['m:interval',{closure=>"closed-open"}];});
DefMathML("Token:?:open-closed-interval",undef,sub{['m:interval',{closure=>"open-closed"}];});

DefMathML("Token:?:inverse",    undef, sub{['m:inverse'];});
DefMathML("Token:?:lambda",     undef, sub{['m:lambda'];});
DefMathML("Token:?:compose",    undef, sub{['m:compose'];});
DefMathML("Token:?:identity",   undef, sub{['m:ident'];});
DefMathML("Token:?:domain",     undef, sub{['m:domain'];});
DefMathML("Token:?:codomain",   undef, sub{['m:codomain'];});
DefMathML("Token:?:image",      undef, sub{['m:image'];});
DefMathML("Token:?:piecewise",  undef, sub{['m:piecewise'];});
DefMathML("Token:?:piece",      undef, sub{['m:piece'];});
DefMathML("Token:?:otherwise",  undef, sub{['m:otherwise'];});

#======================================================================
# Arithmetic, Algebra and Logic:
#   quotient, factorial, divide, max, min, minus, plus, power, rem, times, root
#   gcd, and, or, xor, not, implies, forall, exists, abs, conjugate, arg, real,
#   imaginary, lcm, floor, ceiling.

# BRM:

DefMathML("Token:ADDOP:?",       \&pmml_mo,    undef);
DefMathML("Token:ADDOP:plus",     undef,       sub { ['m:plus'];});
DefMathML("Token:ADDOP:minus",    undef,       sub { ['m:minus'];});
DefMathML('Apply:ADDOP:?',       \&pmml_infix, undef);

DefMathML("Token:MULOP:?",       \&pmml_mo,    undef);
DefMathML('Apply:MULOP:?',       \&pmml_infix, undef);
DefMathML('Apply:?:divide', sub {
  my($op,$num,$den)=@_;
  my $style = $op->getAttribute('fracstyle');
  my $thickness = $op->getAttribute('thickness');
#  ['m:mfrac',{($thickness ? (linethickness=>$thickness):()),
#	    ($style && ($style eq 'inline') ? (bevelled=>'true'):())},
#   pmml_smaller($num),pmml_smaller($den)]; });
  # Bevelled looks crappy (operands too small) in Mozilla, so just open-code it.
  if($style && ($style eq 'inline')){
    ['m:mrow',{},pmml($num),pmml_mo('/'),pmml($den)]; }
  else {
    ['m:mfrac',{($thickness ? (linethickness=>$thickness):())},
     pmml_smaller($num),pmml_smaller($den)]; }});

DefMathML('Apply:MODIFIEROP:?',       \&pmml_infix, undef);
DefMathML("Token:MODIFIEROP:?",         \&pmml_mo,   undef);

DefMathML('Apply:MIDDLE:?',       \&pmml_infix, undef);

DefMathML("Token:SUPOP:?",         \&pmml_mo,   undef);
DefMathML('Apply:SUPERSCRIPTOP:?', \&pmml_script, undef);
DefMathML('Apply:SUBSCRIPTOP:?',   \&pmml_script, undef);
DefMathML('Token:SUPERSCRIPTOP:?', undef, sub{['m:csymbol',{cd=>'ambiguous'},'superscript'];});
DefMathML('Token:SUBSCRIPTOP:?',   undef, sub{['m:csymbol',{cd=>'ambiguous'},'subscript'];});

#DG Experimental: qvars for MWS
DefMathML('Token:?:qvar', undef, sub{['m:csymbol',{cd=>'mws',name=>'qvar'}, $_[0]->textContent];});


DefMathML('Apply:POSTFIX:?', sub {
  ['m:mrow',{},pmml($_[1]),pmml($_[0])]; });

DefMathML('Apply:?:square-root',
	  sub { ['m:msqrt',{},pmml($_[1])]; },
	  sub { ['m:apply',{},['m:root', {}],cmml($_[1])];});
DefMathML('Apply:?:root', 
	  sub { ['m:mroot',{},pmml($_[2]),pmml_smaller($_[1])]; },
	  sub { ['m:apply',{},['m:root', {}],['m:degree',{},cmml($_[1])], cmml($_[2]) ]; } );

# Note MML's distinction between quotient and divide: quotient yeilds an integer
DefMathML("Token:?:quotient",  undef, sub{['m:quotient'];});
DefMathML("Token:?:factorial", undef, sub{['m:factorial'];});
DefMathML("Token:?:divide",    undef, sub{['m:divide'];});
DefMathML("Token:?:maximum",   undef, sub{['m:max'];});
DefMathML("Token:?:minimum",   undef, sub{['m:min'];});
DefMathML("Token:?:minus",     undef, sub{['m:minus'];});
DefMathML("Token:?:uminus",    undef, sub{['m:uminus'];});
DefMathML("Token:?:plus",      undef, sub{['m:plus'];});
DefMathML("Token:?:power",     undef, sub{['m:power'];});
DefMathML("Token:?:remainder", undef, sub{['m:rem'];});
DefMathML("Token:?:times",     undef, sub{['m:times'];});
DefMathML("Token:?:gcd",       undef, sub{['m:gcd'];});
DefMathML("Token:?:and",       undef, sub{['m:and'];});
DefMathML("Token:?:or",        undef, sub{['m:or'];});
DefMathML("Token:?:xor",       undef, sub{['m:xor'];});
DefMathML("Token:?:not",       undef, sub{['m:not'];});
DefMathML("Token:?:implies",   undef, sub{['m:implies'];});
DefMathML("Token:?:forall",    undef, sub{['m:forall'];});
DefMathML("Token:?:exists",    undef, sub{['m:exists'];});
DefMathML("Token:?:absolute-value",undef, sub{['m:abs'];});
DefMathML("Token:?:conjugate", undef, sub{['m:conjugate'];});
DefMathML("Token:?:argument",  undef, sub{['m:arg'];});
DefMathML("Token:?:real-part", undef, sub{['m:real'];});
DefMathML("Token:?:imaginary-part", undef, sub{['m:imaginary'];});
DefMathML("Token:?:lcm",       undef, sub{['m:lcm'];});
DefMathML("Token:?:floor",     undef, sub{['m:floor'];});
DefMathML("Token:?:ceiling",   undef, sub{['m:ceiling'];});

#======================================================================
# Relations:
#   eq, neq, gt, lt, geq, leq, equivalent, approx, factorof

DefMathML("Token:RELOP:?",         \&pmml_mo);
DefMathML("Token:?:equals",               undef, sub{['m:eq'];});
DefMathML("Token:?:not-equals",           undef, sub{['m:neq'];});
DefMathML("Token:?:greater-than",         undef, sub{['m:gt'];});
DefMathML("Token:?:less-than",            undef, sub{['m:lt'];});
DefMathML("Token:?:greater-than-or-equals",undef, sub{['m:geq'];});
DefMathML("Token:?:less-than-or-equals",  undef, sub{['m:leq'];});
DefMathML("Token:?:equivalent-to",        undef, sub{['m:equivalent'];});
DefMathML("Token:?:approximately-equals", undef, sub{['m:approx'];});
DefMathML("Apply:?:not-approximately-equals", undef, sub{my($op,@args)=@_;
							 cmml_synth_not('m:approx',@args);});
DefMathML("Apply:?:less-than-or-approximately-equals", undef, sub{my($op,@args)=@_;
							 cmml_or_compose(['m:lt','m:approx'],@args);});

DefMathML("Token:?:factor-of",            undef, sub{['m:factorof'];});

DefMathML("Token:METARELOP:?",     \&pmml_mo);
DefMathML('Apply:RELOP:?',         \&pmml_infix);
DefMathML('Apply:METARELOP:?',     \&pmml_infix);

# Top level relations
DefMathML('Apply:?:formulae',sub { 
  my($op,@elements)=@_;
  pmml_punctuate($op->getAttribute('separators'),map(pmml($_),@elements)); },
  sub { 
	my($op,@elements)=@_;
	['m:apply',{},['m:csymbol', {cd=>'ambiguous', name=>'formulae-sequence'}],map(cmml($_),@elements)];
  });

# TRICKY: How should this get converted to cmml ???
# DefMathML('Apply:?:multirelation',
# 	  sub { 
# 	    my($op,@elements)=@_;
# 	    pmml_row(map(pmml($_),@elements)); },
# 	  sub {
# 	    my($op,@elements)=@_;
# 	    my @stuff=();
# 	    my $a = cmml(shift(@elements));
# 	    return $a unless @elements;
# 	    while(@elements){
# 	      my $rel = cmml(shift(@elements));
# 	      my $b=cmml(shift(@elements));
# 	      my $id = generate_id('sh');
# 	      $$b[1]{'xml:id'}=$id;
# 	      push(@stuff,['m:apply',{},$rel,$a,$b]);
# 	      $a = ['m:share',{href=>'#'.$id}]; }
# 	    (scalar(@stuff) > 1 ? ['m:and',{},@stuff] : $stuff[0]); }
# 	  );

DefMathML('Apply:?:multirelation',
	  sub { 
	    my($op,@elements)=@_;
	    # This presumes that the relational operators scattered through here
	    # will be recognized as such by pmml and turned into m:mo
 	    pmml_row(map(pmml($_),@elements)); },
	  sub {
	    my($op,@elements)=@_;
	    my $a = cmml(shift(@elements));
	    return $a unless @elements;
	    my @relations=();
	    while(@elements){
	      my $rel = shift(@elements);
	      my $b   = shift(@elements);
	      push(@relations,['m:apply',{},cmml($rel),$a,cmml_shared($b)]);
	      $a = cmml_share($b); }
	    (scalar(@relations) > 1 ? ['m:apply',{},['m:and',{}],@relations] : $relations[0]); }
	  );

#======================================================================
# Calculus and Vector Calculus:
#   int, diff, partialdiff, lowlimit, uplimit, bvar, degree, 
#   divergence, grad, curl, laplacian.

DefMathML("Token:INTOP:?",       \&pmml_mo);
DefMathML("Token:LIMITOP:?",     \&pmml_mo);
DefMathML('Apply:ARROW:?',       \&pmml_infix);

DefMathML("Token:?:integral",             undef, sub{['m:int'];});
DefMathML("Token:?:differential",         undef, sub{['m:diff'];});
DefMathML("Token:?:partial-differential", undef, sub{['m:partialdiff'];});
# lowlimit, uplimit, degree ?
DefMathML("Token:?:divergence",           undef, sub{['m:divergence'];});
DefMathML("Token:?:gradient",             undef, sub{['m:grad'];});
DefMathML("Token:?:curl",                 undef, sub{['m:curl'];});
DefMathML("Token:?:laplacian",            undef, sub{['m:laplacian'];});

#======================================================================
# Theory of Sets,
#   set, list, union, intersect, in, notin, subset, prsubset, notsubset, notprsubset,
#   setdiff, card, cartesianproduct.

DefMathML("Token:?:set",              undef, sub{['m:set'];});
DefMathML("Token:?:list",             undef, sub{['m:list'];});
DefMathML("Token:?:union",            undef, sub{['m:union'];});
DefMathML("Token:?:intersection",     undef, sub{['m:intersect'];});
DefMathML("Token:?:element-of",       undef, sub{['m:in'];});
DefMathML("Token:?:not-element-of",   undef, sub{['m:notin'];});
DefMathML("Apply:?:contains",         undef, sub{ my($op,@args)=@_;
						  cmml_synth_complement('m:in',@args);});
DefMathML("Apply:?:not-contains",     undef, sub{ my($op,@args)=@_;
						  cmml_synth_complement('m:notin',@args);});
DefMathML("Token:?:subset-of",                undef, sub{['m:subset'];});
DefMathML("Token:?:subset-of-or-equals",      undef, sub{['m:subset'];});
DefMathML("Token:?:subset-of-and-not-equals", undef, sub{['m:prsubset'];});
DefMathML("Apply:?:superset-of",              undef, sub{ my($op,@args)=@_;
							  cmml_synth_complement('m:subset',@args); });
DefMathML("Apply:?:superset-of-or-equals",    undef, sub{ my($op,@args)=@_;
							  cmml_synth_complement('m:subset',@args); });
DefMathML("Apply:?:superset-of-and-not-equals",undef,sub{ my($op,@args)=@_;
							  cmml_synth_complement('m:prsubset',@args); });
DefMathML("Token:?:set-minus",        undef, sub{['m:setdiff'];});
DefMathML("Token:?:cardinality",      undef, sub{['m:card'];});
DefMathML("Token:?:cartesian-product",undef, sub{['m:cartesianproduct'];});

# The following macros work on simple relations. Fail on multirelations.
DefMathML("Apply:?:superset-of", \&pmml_infix,
sub{
  my($op,@elements)=@_;
  my(@rev)=reverse(@elements);
  ['m:apply',{},['m:prsubset',{}],map(cmml($_),@rev)];});

DefMathML("Apply:?:superset-of-or-equals", \&pmml_infix,
sub{
  my($op,@elements)=@_;
  my(@rev)=reverse(@elements);
  ['m:apply',{},['m:subset',{}],map(cmml($_),@rev)];});

DefMathML("Apply:?:not-superset-of", \&pmml_infix,
sub{
  my($op,@elements)=@_;
  my(@rev)=reverse(@elements);
  ['m:apply',{},['m:notprsubset',{}],map(cmml($_),@rev)];});

DefMathML("Apply:?:not-superset-of-or-equals", \&pmml_infix,
sub{
  my($op,@elements)=@_;
  my(@rev)=reverse(@elements);
  ['m:apply',{},['m:notsubset',{}],map(cmml($_),@rev)];});

#======================================================================
# Sequences and Series:
#   sum, product, limit, tendsto
# (but see calculus for limit too!!)

DefMathML("Token:SUMOP:?",       \&pmml_mo);
sub pmml_bigop {
  my($op,$body)=@_;
  ['m:mrow',{}, pmml($op), pmml_unrow(pmml($body))]; }
DefMathML('Apply:BIGOP:?',\&pmml_bigop);
DefMathML('Apply:INTOP:?',\&pmml_bigop);
DefMathML('Apply:SUMOP:?',\&pmml_bigop);

DefMathML('Apply:?:limit-from', sub {
  my($op,$arg,$dir)=@_;
  ['m:mrow',{},pmml($arg),pmml($dir)]; });

DefMathML('Apply:?:annotated', sub {
  my($op,$var,$annotation)=@_;
  ['m:mrow',{},pmml($var),['m:mspace',{width=>'veryverythickmathspace'}],pmml($annotation)];});

# NOTE: Markup probably isn't right here....
DefMathML('Apply:?:evaluated-at', sub {
  my($op,$expr,$value1,$value2)=@_;
#   if($value2){
#     pmml_row(pmml($expr),['m:msubsup',{},pmml_mo('|'),pmml_scriptsize($value1),pmml_scriptsize($value2)]); }
#   else {
#     pmml_row(pmml($expr),['m:msub',{},pmml_mo('|'),pmml_scriptsize($value1)]); }});
  # Try with mfenced
  if($value2){
    ['m:msubsup',{},
     ['m:mfenced',{open=>'',close=>'|'},pmml($expr)],
     pmml_scriptsize($value1),pmml_scriptsize($value2)]; }
  else {
    ['m:msub',{},
     ['m:mfenced',{open=>'',close=>'|'},pmml($expr)],
     pmml_scriptsize($value1)]; }});

DefMathML("Token:?:sum",          undef, sub{['m:sum'];});
DefMathML("Token:?:prod",         undef, sub{['m:prod'];});
DefMathML("Token:?:limit",        undef, sub{['m:limit'];});
DefMathML("Token:?:tends-to",     undef, sub{['m:tendsto'];});

#======================================================================
# Elementary Classical Functions,
#   exp, ln, log, sin, cos tan, sec, csc, cot, sinh, cosh, tanh, sech, csch, coth,
#   arcsin, arccos, arctan, arccosh, arccot, arccoth, arccsc, arccsch, arcsec, arcsech,
#   arcsinh, arctanh

DefMathML("Token:?:exponential",                   undef, sub { ['m:exp']; });
DefMathML("Token:?:natural-logarithm",             undef, sub { ['m:ln']; });
DefMathML("Token:?:logarithm",                     undef, sub { ['m:log']; });
DefMathML("Token:?:sine",                          undef, sub { ['m:sin']; });
DefMathML("Token:?:cosine",                        undef, sub { ['m:cos']; });
DefMathML("Token:?:tangent",                       undef, sub { ['m:tan']; });
DefMathML("Token:?:secant",                        undef, sub { ['m:sec']; });
DefMathML("Token:?:cosecant",                      undef, sub { ['m:csc']; });
DefMathML("Token:?:cotangent",                     undef, sub { ['m:cot']; });
DefMathML("Token:?:hyperbolic-sine",               undef, sub { ['m:sinh']; });
DefMathML("Token:?:hyperbolic-cosine",             undef, sub { ['m:cosh']; });
DefMathML("Token:?:hyperbolic-tangent",            undef, sub { ['m:tanh']; });
DefMathML("Token:?:hyperbolic-secant",             undef, sub { ['m:sech']; });
DefMathML("Token:?:hyperbolic-cosecant",           undef, sub { ['m:csch']; });
DefMathML("Token:?:hyperbolic-cotantent",          undef, sub { ['m:coth']; });
DefMathML("Token:?:inverse-sine",                  undef, sub { ['m:arcsin']; });
DefMathML("Token:?:inverse-cosine",                undef, sub { ['m:arccos']; });
DefMathML("Token:?:inverse-tangent",               undef, sub { ['m:arctan']; });
DefMathML("Token:?:inverse-secant",                undef, sub { ['m:arcsec']; });
DefMathML("Token:?:inverse-cosecant",              undef, sub { ['m:arccsc']; });
DefMathML("Token:?:inverse-cotangent",             undef, sub { ['m:arccot']; });
DefMathML("Token:?:inverse-hyperbolic-sine",       undef, sub { ['m:arcsinh']; });
DefMathML("Token:?:inverse-hyperbolic-cosine",     undef, sub { ['m:arccosh']; });
DefMathML("Token:?:inverse-hyperbolic-tangent",    undef, sub { ['m:arctanh']; });
DefMathML("Token:?:inverse-hyperbolic-secant",     undef, sub { ['m:arcsech']; });
DefMathML("Token:?:inverse-hyperbolic-cosecant",   undef, sub { ['m:arccsch']; });
DefMathML("Token:?:inverse-hyperbolic-cotangent",  undef, sub { ['m:arccoth']; });

#======================================================================
# Statistics:
#   mean, sdev, variance, median, mode, moment, momentabout

DefMathML("Token:?:mean",               undef, sub{['m:mean'];});
DefMathML("Token:?:standard-deviation", undef, sub{['m:sdev'];});
DefMathML("Token:?:variance",           undef, sub{['m:var'];});
DefMathML("Token:?:median",             undef, sub{['m:median'];});
DefMathML("Token:?:mode",               undef, sub{['m:mode'];});
DefMathML("Token:?:moment",             undef, sub{['m:moment'];});
# momentabout ???

#======================================================================
# Linear Algebra:
#   vector, matrix, matrixrow, determinant, transpose, selector, 
#   vectorproduct, scalarproduct, outerproduct.

DefMathML("Token:?:vector",         undef, sub{['m:vector'];});
DefMathML("Token:?:matrix",         undef, sub{['m:matrix'];});
DefMathML("Token:?:determinant",    undef, sub{['m:determinant'];});
DefMathML("Token:?:transpose",      undef, sub{['m:transpose'];});
DefMathML("Token:?:selector",       undef, sub{['m:selector'];});
DefMathML("Token:?:vector-product", undef, sub{['m:vectorproduct'];});
DefMathML("Token:?:scalar-product", undef, sub{['m:scalarproduct'];});
DefMathML("Token:?:outer-product",  undef, sub{['m:outerproduct'];});

#======================================================================
# Semantic Mapping Elements
#   annotation, semantics, annotation-xml
#======================================================================
# Constant and Symbol Elements
#   integers, reals, rationals, naturalnumbers, complexes, primes,
#   exponentiale, imaginaryi, notanumber, true, false, emptyset, pi,
#   eulergamma, infinity

DefMathML("Token:ID:integers",       undef, sub{['m:integers'];});
DefMathML("Token:ID:reals",          undef, sub{['m:reals'];});
DefMathML("Token:ID:rationals",      undef, sub{['m:rationals'];});
DefMathML("Token:ID:numbers",        undef, sub{['m:naturalnumbers'];});
DefMathML("Token:ID:complexes",      undef, sub{['m:complexes'];});
DefMathML("Token:ID:primes",         undef, sub{['m:primes'];});
DefMathML("Token:ID:exponential-e",  undef, sub{['m:exponentiale'];});
DefMathML("Token:ID:imaginary-i",    undef, sub{['m:imaginaryi'];});
DefMathML("Token:ID:notanumber",     undef, sub{['m:notanumber'];});
DefMathML("Token:ID:true",           undef, sub{['m:true'];});
DefMathML("Token:ID:false",          undef, sub{['m:false'];});
DefMathML("Token:ID:empty-set",      undef, sub{['m:emptyset'];});
DefMathML("Token:ID:circular-pi",    undef, sub{['m:pi'];});
DefMathML("Token:ID:Euler-constant", undef, sub{['m:eulergamma'];});
DefMathML("Token:ID:infinity",       undef, sub{['m:infinity'];});

#======================================================================
# Purely presentational constructs.
# An issue here:
#  Some constructs are pretty purely presentational.  Hopefully, these would
# only appear in XWrap's or in the presentation branch of an XMDual, so we won't
# attempt to convert them to content.  But if we do, should we warn?

DefMathML('Apply:FENCED:?',sub {
  my($op,@elements)=@_;
  pmml_parenthesize(pmml_punctuate($op->getAttribute('separators'),map(pmml($_),@elements)),
		    $op->getAttribute('argopen'), $op->getAttribute('argclose')); });

# Note how annoyingly MML's arrays don't change the style the same
# way TeX does!
DefMathML('Apply:STACKED:?', sub {
  my($op,$over,$under)=@_;
  my $stack = ['m:mtable',{rowspacing=>"0.2ex", columnspacing=>"0.4em"},
	       ['m:mtr',{},['m:mtd',{},pmml($over)]],
	       ['m:mtr',{},['m:mtd',{},pmml($under)]]];
  if($LaTeXML::MathML::STYLE =~/^(text|script)$/){
    ['m:mstyle',{scriptlevel=>'+1'},$stack]; }
  else {
    $stack; }});

# ================================================================================
# cfrac! Ugh!

# Have to deal w/ screwy structure:
# If denom is a sum/diff then last summand can be: cdots, cfrac 
#  or invisibleTimes of cdots and something which could also be a cfrac!
# There is some really messy manipulation of display/text style...probably not all correct.
sub do_cfrac {
  my($numer,$denom)=@_;
  if(getQName($denom) eq 'ltx:XMApp'){ # Denominator is some kind of application
    my ($denomop,@denomargs)=element_nodes($denom);
    if((($denomop->getAttribute('role')||'') eq 'ADDOP') # Is it a sum or difference?
       || (($denomop->textContent ||'') eq "\x{22EF}") ){ # OR a \cdots
      my $last = pop(@denomargs);			# Check last operand in denominator.
      # this is the current contribution to the cfrac (if we match the last term)
      my $curr;
      { local $LaTeXML::MathML::STYLE = 'text';
	$curr = ['m:mfrac',{},pmml($numer),
		 ['m:mrow',{},
		  (@denomargs > 1 ? pmml_infix($denomop,@denomargs) : pmml($denomargs[0])),
		  pmml($denomop)]]; }
      $curr = ['m:mstyle',{displaystyle=>'true'},$curr]
	unless $LaTeXML::MathML::STYLE eq 'display';
      if(($last->textContent ||'') eq "\x{22EF}"){ # Denom ends w/ \cdots
	return ($curr,pmml($last));}		   # bring dots up to toplevel
      elsif(getQName($last) eq 'ltx:XMApp'){	   # Denom ends w/ application --- what kind?
	my($lastop,@lastargs)=element_nodes($last);
	if(($lastop->getAttribute('meaning')||'') eq 'continued-fraction'){ # Denom ends w/ cfrac, pull it to toplevel
	 return ($curr,do_cfrac(@lastargs)); }
##	  my @p;
##	  { $LaTeXML::MathML::STYLE = 'text'; # Trick into being treated as display.
##	    @p = do_cfrac(@lastargs); }
##	return ($curr,@p); }
#	  return ($curr,pmml($last)); }
	elsif((($lastop->textContent||'') eq "\x{2062}")  # Denom ends w/ * (invisible)
	      && (scalar(@lastargs)==2) && (($lastargs[0]->textContent||'') eq "\x{22EF}")){
	  my($n,$d);
	  $n = pmml($lastargs[0]);
	  { local $LaTeXML::MathML::STYLE = 'text'; # Trick into being treated as display.
	    $d = pmml($lastargs[1])}
	  return ($curr,$n,$d); }}}}
##  (['m:mfrac',{},pmml_smaller($numer),pmml_smaller($denom)]); }
  if( $LaTeXML::MathML::STYLE eq 'display'){
    ['m:mfrac',{},pmml_smaller($numer),pmml_smaller($denom)]; }
  else {
    local $LaTeXML::MathML::STYLE = 'display'; # Trick into being treated as display.
    (['m:mstyle',{displaystyle=>'true'},
      ['m:mfrac',{},pmml_smaller($numer),pmml_smaller($denom)]]); }}

DefMathML('Apply:?:continued-fraction', sub {
  my($op,$numer,$denom)=@_;
  my $style = $op->getAttribute('fracstyle')||'display';
  if($style eq 'inline'){
    pmml_row(do_cfrac($numer,$denom)); }
  else {
    local $LaTeXML::MathML::STYLE = 'text';
    ['m:mfrac',{},pmml($numer),pmml($denom)]; }});

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Specific converters for Presentation, Content, or Parallel.
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#================================================================================
# Presentation MathML
package LaTeXML::Post::MathML::Presentation;
use strict;
use base qw(LaTeXML::Post::MathML);

sub convertNode {
  my($self,$doc,$xmath,$style)=@_;
  my @trans = $self->pmml_top($xmath,$style);
  (scalar(@trans)> 1 ? ['m:mrow',{},@trans] : $trans[0]); }

sub getEncodingName { 'MathML-Presentation'; }
sub rawIDSuffix { '.pmml'; }

#================================================================================
# Presentation MathML with Line breaking
# Not at all sure how this will integrate with Parallel markup...
package LaTeXML::Post::MathML::PresentationLineBreak;
use strict;
use base qw(LaTeXML::Post::MathML::Presentation);
use LaTeXML::Util::MathMLLinebreaker;

# Any displayed formula is a candidate for line-breaking.
# If it is not already in a MathFork, and needs line-breaking,
# then we ought to wrap in a MathFork, so as to preserve the
# slightly "semantically meaningful" form.
# If we're mangling the document structure in this way,
# it needs to be done before the main scan-all-math's loop,
# since it moves the maths around.
# However, since we also have to check whether it NEEDS line breaking beforehand,
# we might as well linebreak & store that line-broken result alongside.
# [it will get stored WITHOUT an XMath expression, though, so we won't be asked to redo it]
# convertNode will be called later on the main fork (unbroken).
# Also, other subexpressions inside MathFork/MathBranch that were created by
# the usual means (bindings for eqnarray, or whatever) will still need to
# be converted (convertNode).
# And in fact they also should be line-broken -- we just don't know the width!!
sub preprocess {
  my($self,$doc,@maths)=@_;
  $self->SUPER::preprocess($doc,@maths);
  my $linelength = $$self{linelength} || 80;
  my $breaker = LaTeXML::Util::MathMLLinebreaker->new();
  # Rewrap every displayed ltx:Math in an ltx:MathFork (if it isn't ALREADY in a MathFork).
  # This is so that we can preserve the "more semantic" non-linebroken form as the main branch.
  foreach my $math (@maths){
    my $mode = $math->getAttribute('mode')||'inline';
    next unless $mode eq 'display'; # SKIP if not in display mode?
    # If already has in a MathBranch, we can't really know if, or how wide, to line break!?!?!
    next if $doc->findnodes('ancestor::ltx:MathFork',$math); # SKIP if already in a branch?
    # Now let's do the layout & see if it actually needs line breaks!
    # next if $math isn't really so wide ..
    my $xmath = $doc->findnode('ltx:XMath',$math);
    my $pmml = $self->SUPER::convertNode($doc,$xmath,($mode eq 'display' ? 'display' : 'text'));
    my $layout = $breaker->bestFitToWidth($xmath,$pmml,$linelength,1);
##print STDERR "MATH ".($math->getAttribute('xml:id')||'<unk>')
##  ." = ".$$layout{width}.($$layout{hasbreak} ? " (broken $$layout{penalty})":" (unbroken)")."\n";
    my $id = $math->getAttribute('xml:id');
    if($$layout{hasbreak}){	# YES it did linebreak!
      my $n = $math->parentNode;
      my $path = '';
      # Replace the Math node with a MathFork that contains the Math node.
      # And a MathBranch that ONLY contains the line-broken pmml.
      # That branch won't get other parallel markup,
      # but the main, more semantic(?) one, will and will get the unbroken pmml, as well.
      my $p = $math->parentNode;
      my $bid = $id && $id.".mbr";
      $doc->replaceNode($math,['ltx:MathFork',{},$math,
			       ['ltx:MathBranch',{},
				['ltx:Math',{'xml:id'=>$bid},
				 $self->outerWrapper($doc,$math,
						     $breaker->applyLayout($pmml,$layout))]]]);
      # Might as well cache the converted pmml?
      # [But note that applyLayout MODIFIED the orignal $pmml, so it's got linebreaks!]
      if($bid){
	$$doc{converted_pmml_cache}{$bid} = $pmml; }
    }
    elsif($id){
      $$doc{converted_pmml_cache}{$id} = $pmml; }
 }}
  
sub convertNode {
  my($self,$doc,$xmath,$style)=@_;
  my $id = $xmath->parentNode->getAttribute('xml:id');
  if(my $pmml = $id && $$doc{converted_pmml_cache}{$id}){
    $pmml; }
  # A straight displayed Math will have been handled by preprocess, above,
  # and, if it needed line-breaking, will have generated a MathFork/MathBranch.
  # Other math, in the non-semantic side of a MathFork, may want to line break here as well.
  # It presumably will NOT be display style(?)
  # NEXT better strategy will be to scan columns of MathBranches to establish desired line length?
  else {
    my $pmml = $self->SUPER::convertNode($doc,$xmath,$style);
    if(($doc->findnodes('ancestor::ltx:MathBranch',$xmath)) # In formatted side of MathFork?
       # But ONLY if last column!! (until we can adapt LineBreaker!)
       && !$doc->findnodes('parent::ltx:Math/parent::ltx:td/following-sibling::ltx:td',$xmath)){
      my $linelength = $$self{linelength} || 80;	       # Maybe should be shorter!!
      my $breaker = LaTeXML::Util::MathMLLinebreaker->new();
      my $layout = $breaker->bestFitToWidth($xmath,$pmml,$linelength,1);
      if($$layout{hasbreak}){	# YES it did linebreak!
	$pmml = $breaker->applyLayout($pmml,$layout); }}
    $pmml; }}

#================================================================================
# Content MathML
package LaTeXML::Post::MathML::Content;
use strict;
use base qw(LaTeXML::Post::MathML);

sub convertNode {
  my($self,$doc,$xmath,$style)=@_;
  $self->cmml_top($xmath); }

sub getEncodingName { 'MathML-Content'; }
sub rawIDSuffix { '.cmml'; }

#================================================================================
1;

__END__

=pod

=head1 NAME

C<LaTeXML::Post::MathML>, C<LaTeXML::Post::MathML::Presentation>, C<LaTeXML::Post::MathML::Content>
- Post-Processing modules for converting math to MathML.

=head1 SYNOPSIS

C<LaTeXML::Post::MathML> is the abstract base class for the MathML Postprocessor;
C<LaTeXML::Post::MathML::Presentation> and C<LaTeXML::Post::MathML::Content>
convert XMath to either Presentation or Content MathML, or with that format
as the principle branch for Parallel markup.

=head1 DESCRIPTION

The conversion is carried out primarly by a tree walk of the C<XMath> expression;
appropriate handlers are selected and called depending on the operators and forms encountered.
Handlers can be defined on applications of operators, or on tokens;
when a token is applied, it's application handler takes precedence over it's token handler

=head2 C<< DefMathML($key,$presentation,$content); >>

Defines presentation and content handlers for C<$key>.
C<$key> is of the form C<TYPE:ROLE:MEANING>, where

  TYPE    : is one either C<Token> or C<Apply> (or C<Hint> ?)
  ROLE    : is a grammatical role (on XMath tokens)
  MEANING : is the meaning attribute (on XMath tokens)

Any of these can be C<?> to match any role or meaning;
matches of both are preferred, then match of meaning
or role, or neither.

The subroutine handlers for presentation and content are given
by C<$presentation> and C<$content>, respectively.
Either can be C<undef>, in which case some other matching
handler will be invoked.

For C<Token> handlers, the arguments passed are the token node;
for C<Apply> handler, the arguments passed are the operator node
and any arguments.

However, it looks like some C<TOKEN> handlers are being defined
to take C<$content,%attributes> being the string content of the token,
and the token's attributes!

=head2 Presentation Conversion Utilties

=over

=item C<< $mmlpost->pmml_top($node,$style); >>

This is the top-level converter applied to an C<XMath> node.
It establishes a local context for font, style, size, etc.
It generally does the bulk of the work for a PresentationMathML's C<translateNode>,
although the latter wraps the actual C<m:math> element around it.
(C<style> is display or text).

=item C<pmml($node)>, C<pmml_smaller($node)>, C<pmml_scriptsizsize($node)>

Converts the C<XMath> C<$node> to Presentation MathML.
The latter two are used when the context calls for smaller (eg. fraction parts)
or scriptsize (eg sub or superscript) size or style, so that the size encoded
within C<$node> will be properly accounted for.

=item C<pmml_mi($node,%attributes)>, C<pmml_mn($node,%attributes)>, C<pmml_mo($node,%attributes)>

These are C<Token> handlers, to create C<m:mi>, C<m:mn> and C<m:mo> elements,
respectively.  When called as a handler, they will be supplied only with an C<XMath>
node (typically an C<XMTok>). For convenient reuse, these functions may also be called
on a 'virtual' token: with C<$node> being a string (that would have been the text
content of the C<XMTok>), and the C<%attributes> that would have been the token's attributes.

=item C<pmml_infix($op,@args)>, C<pmml_script($op,@args)>, C<pmml_bigop($op,@args)>

These are C<Apply> handlers, for handling general infix, sub or superscript,
or bigop (eg. summations) constructs.  They are called with the operator
token, followed by the arguments; all are C<XMath> elements.

=item C<pmml_row(@items)>

This wraps an C<m:mrow> around the already converted C<@items> if neeed;
That is, if there is only a single item it is returned without the C<m:mrow>.

=item C<pmml_unrow($pmml)>

This perverse utility takes something that has already been converted
to Presentation MathML.  If the argument is an C<m:mrow>, it returns a list of the
mathml elements within that row, otherwise it returns a list containing
the single element C<$pmml>.

=item C<pmml_parenthesize($item,$open,$close)>

This utility parenthesizes the (already converted MathML) C<$item> with the string delimiters
C<$open> and C<$close>.  Currently, it converts to an C<m:mfenced>
(But could convert to an C<m:mrow>).

=item C<pmml_punctuate($separators,@items) >

This utility creates an C<m:mrow> by interjecting the punctuation
between suceessive items in the list of already converted C<@items>.
If there are more than one character in C<$separators> the first
is used between the first pair, the next between the next pair;
if the separators is exhausted, the last is repeated between remaining pairs.
C<$separators> defaults to (repeated) comma.

=back

=head2 Content Conversion Utilties

=over

=item C<$mmlpost->cmml_top($node); >

This is the top-level converter applied to an C<XMath> node.
It establishes a local context for font, style, size, etc (were it needed).
It generally does the bulk of the work for a ContentMathML's C<translateNode>,
although the latter wraps the actual C<m:math> element around it.

=item C<cmml($node)>

Converts the C<XMath> C<$node> to Content MathML.

=item C<cmml_ci($token)>

Converts the C<XMath> token to an C<m:ci>.
(This may evolve to generate a C<m:csymbol>, under appropriate circumstances)

=item C<cmml_decoratedSymbol($item)>

Similar to C<cmml_ci>, but used when an operator is itself, apparently, an application.
This converts C<$item> to Presentation MathML to use for the content of the C<m:ci>.

=item C<cmml_not($arg)>

Construct the not of the argument C<$arg>.

=item C<cmml_synth_not($op,@args)>

Synthesize an operator by applying C<m:not> to another operator (C<$op>) applied to its C<@args>
(C<XMath> elements that will be converted to Content MathML).
This is useful to define a handler for, eg., c<not-approximately-equals> in terms
of c<m:approx>.

=item C<cmml_synth_complement($op,@args)>

Synthesize an operator by applying a complementary operator (C<$op>) to the reverse of its C<@args>
(C<XMath> elements that will be converted to Content MathML).
This is useful to define a handler for, eg. C<superset-of-or-equals> using C<m:subset>.

=item C<cmml_or_compose($operators,@args)>

Synthesize an operator that stands for the C<or> of several other operators
(eg. c<less-than-or-similar-to-or-approximately-equals>) by composing it
of the C<m:or> of applying each of C<m:less> and C<m:approx> to the arguments.
The first operator is applied to the converted arguments, while the rest
are applied to C<m:share> elements referring to the previous ones.

=item C<cmml_share($node)>

Converts the C<XMath> C<$node> to Content MathML, after assuring that it has an id,
so that it can be shared.

=item C<cmml_shared($node)>

Generates a C<m:share> element referting to C<$node>, which should have 
an id (such as after calling C<cmml_share>).

=back

=head1 Math Processors, Generally.

We should probably formalize the idea of a Math Processor as an
abstract class, but let this description provide a starting overview.
A MathProcessor follows the API of C<LaTeXML::Post> processors, by
handling C<process>, which invokes C<processNode> on all C<Math> nodes;
That latter inserts the result of either C<translateNode> or
C<translateParallel>, applied to the C<XMath> representation, into the C<Math> node.

Parallel translation is done whenever additional MathProcessors have
been specified, via the C<setParallel> method; these are simply other
MathProcessors following the same API.

=cut
